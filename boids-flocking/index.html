<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Boids Flocking</title>
<style>
* { margin: 0; padding: 0; }
body { background: #0a0a1a; overflow: hidden; }
canvas { display: block; }
#ui { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  color: #fff8; font: 13px system-ui; text-align: center; pointer-events: none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">click to attract · move mouse to disturb · scroll to zoom</div>
<script>
const c = document.getElementById('c');
const ctx = c.getContext('2d');
let W, H, mx = -9999, my = -9999, clicking = false, zoom = 1;
const N = 300;
const boids = [];

function resize() { W = c.width = innerWidth; H = c.height = innerHeight; }
resize();
addEventListener('resize', resize);
addEventListener('mousemove', e => { mx = e.clientX; my = e.clientY; });
addEventListener('mousedown', () => clicking = true);
addEventListener('mouseup', () => clicking = false);
addEventListener('wheel', e => { zoom = Math.max(0.3, Math.min(3, zoom + e.deltaY * -0.001)); });
addEventListener('touchmove', e => { mx = e.touches[0].clientX; my = e.touches[0].clientY; });

const palette = ['#ff6b6b','#ffd93d','#6bcb77','#4d96ff','#ff6bd6','#6bfff1'];

class Boid {
  constructor() {
    this.x = Math.random() * W;
    this.y = Math.random() * H;
    const a = Math.random() * Math.PI * 2;
    this.vx = Math.cos(a) * 2;
    this.vy = Math.sin(a) * 2;
    this.color = palette[Math.floor(Math.random() * palette.length)];
    this.trail = [];
  }
  update(flock) {
    let sx=0,sy=0,cx=0,cy=0,ax=0,ay=0,sc=0,cc=0,ac=0;
    const perception = 60 * zoom, avoidR = 25 * zoom;
    for (const b of flock) {
      if (b === this) continue;
      const dx = b.x-this.x, dy = b.y-this.y, d = Math.sqrt(dx*dx+dy*dy);
      if (d < perception) {
        // alignment
        ax += b.vx; ay += b.vy; ac++;
        // cohesion
        cx += b.x; cy += b.y; cc++;
        // separation
        if (d < avoidR) { sx -= dx/d; sy -= dy/d; sc++; }
      }
    }
    if (ac) { ax/=ac; ay/=ac; this.steer(ax,ay,0.05); }
    if (cc) { cx/=cc; cy/=cc; this.steer(cx-this.x,cy-this.y,0.03); }
    if (sc) { this.steer(sx,sy,0.08); }

    // mouse interaction
    const dmx=mx-this.x, dmy=my-this.y, dm=Math.sqrt(dmx*dmx+dmy*dmy);
    if (dm < 150) {
      if (clicking) { this.steer(dmx,dmy,0.15); }
      else { this.steer(-dmx,-dmy,0.12); }
    }

    // edges: wrap
    if (this.x<0) this.x=W; if (this.x>W) this.x=0;
    if (this.y<0) this.y=H; if (this.y>H) this.y=0;

    const spd = Math.sqrt(this.vx*this.vx+this.vy*this.vy);
    const maxSpd = 4;
    if (spd > maxSpd) { this.vx=(this.vx/spd)*maxSpd; this.vy=(this.vy/spd)*maxSpd; }
    if (spd < 1.5) { this.vx=(this.vx/spd)*1.5; this.vy=(this.vy/spd)*1.5; }

    this.x += this.vx; this.y += this.vy;
    this.trail.push({x:this.x,y:this.y});
    if (this.trail.length > 8) this.trail.shift();
  }
  steer(tx,ty,force) {
    const m = Math.sqrt(tx*tx+ty*ty) || 1;
    this.vx += (tx/m)*force*4; this.vy += (ty/m)*force*4;
  }
  draw() {
    const a = Math.atan2(this.vy, this.vx);
    const s = 6;
    // trail
    ctx.beginPath();
    for (let i=0;i<this.trail.length;i++) {
      const t=this.trail[i], alpha=i/this.trail.length*0.3;
      ctx.fillStyle = this.color + Math.floor(alpha*255).toString(16).padStart(2,'0');
      ctx.fillRect(t.x, t.y, 2, 2);
    }
    // body
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(a);
    ctx.beginPath();
    ctx.moveTo(s, 0);
    ctx.lineTo(-s*0.6, s*0.4);
    ctx.lineTo(-s*0.6, -s*0.4);
    ctx.closePath();
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.restore();
  }
}

for (let i=0;i<N;i++) boids.push(new Boid());

function frame() {
  ctx.fillStyle = 'rgba(10,10,26,0.15)';
  ctx.fillRect(0,0,W,H);
  for (const b of boids) b.update(boids);
  for (const b of boids) b.draw();
  requestAnimationFrame(frame);
}
frame();
</script>
</body>
</html>
