<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a0a1a">
<title>VECTOR SIEGE</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;user-select:none}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:'Courier New',monospace;touch-action:none}
canvas{display:block;position:absolute;top:0;left:0;width:100%;height:100%}
#ui{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}

/* Title Screen */
#title-screen{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:all;z-index:20;transition:opacity 0.6s ease,transform 0.6s ease}
#title-screen.hidden{opacity:0;transform:scale(1.1);pointer-events:none}
.title-main{font-size:clamp(2.5rem,8vw,5rem);font-weight:900;letter-spacing:0.3em;color:#fff;text-shadow:0 0 20px #0ff,0 0 40px #0ff,0 0 80px #08f;margin-bottom:0.1em;text-align:center;animation:titlePulse 3s ease-in-out infinite}
.title-sub{font-size:clamp(0.7rem,2.5vw,1.2rem);letter-spacing:0.8em;color:#0ff;opacity:0.7;margin-bottom:2em;text-transform:uppercase}
@keyframes titlePulse{0%,100%{text-shadow:0 0 20px #0ff,0 0 40px #0ff,0 0 80px #08f}50%{text-shadow:0 0 30px #0ff,0 0 60px #0ff,0 0 120px #08f,0 0 160px #04f}}

.play-btn{pointer-events:all;background:transparent;border:2px solid #0ff;color:#0ff;font-family:inherit;font-size:clamp(1rem,3vw,1.4rem);letter-spacing:0.4em;padding:0.8em 2.5em;cursor:pointer;position:relative;overflow:hidden;transition:all 0.3s ease;text-transform:uppercase}
.play-btn:hover,.play-btn:active{background:rgba(0,255,255,0.15);box-shadow:0 0 30px rgba(0,255,255,0.4),inset 0 0 30px rgba(0,255,255,0.1);transform:scale(1.05)}
.play-btn::before{content:'';position:absolute;top:-2px;left:-2px;right:-2px;bottom:-2px;background:linear-gradient(45deg,#0ff,#f0f,#0ff);z-index:-1;filter:blur(10px);opacity:0;transition:opacity 0.3s}
.play-btn:hover::before,.play-btn:active::before{opacity:0.5}

.high-score-display{margin-top:1.5em;color:#f0f;font-size:clamp(0.7rem,2vw,0.9rem);letter-spacing:0.3em;text-shadow:0 0 10px #f0f;opacity:0.8}
.stats-display{margin-top:0.6em;color:#888;font-size:clamp(0.55rem,1.5vw,0.7rem);letter-spacing:0.2em}
.controls-hint{margin-top:1.5em;color:#555;font-size:clamp(0.45rem,1.3vw,0.6rem);letter-spacing:0.15em;text-align:center;line-height:2}

/* HUD */
#hud{position:absolute;top:0;left:0;width:100%;padding:env(safe-area-inset-top,10px) 15px 0;display:flex;justify-content:space-between;align-items:flex-start;z-index:15;opacity:0;transition:opacity 0.4s}
#hud.visible{opacity:1}
.hud-left{display:flex;flex-direction:column}
.hud-right{display:flex;flex-direction:column;align-items:flex-end;margin-right:45px}
.hud-score{font-size:clamp(1.1rem,3.5vw,1.8rem);color:#fff;text-shadow:0 0 10px #0ff;letter-spacing:0.1em;font-weight:700;transition:color 0.1s}
.hud-score.bump{color:#ff0;text-shadow:0 0 15px #ff0}
.hud-hi{font-size:clamp(0.55rem,1.8vw,0.75rem);color:#f0f;letter-spacing:0.15em;opacity:0.7;margin-top:2px}
.hud-wave{font-size:clamp(0.6rem,2vw,0.85rem);color:#0f0;letter-spacing:0.2em;text-shadow:0 0 8px #0f0}
.hud-combo{font-size:clamp(0.55rem,1.6vw,0.7rem);color:#ff0;letter-spacing:0.15em;text-shadow:0 0 8px #ff0;opacity:0;transition:opacity 0.2s;margin-top:4px}
.hud-combo.visible{opacity:1}

/* Smart bomb meter */
#bomb-meter{position:absolute;top:50%;right:15px;transform:translateY(-50%);width:8px;height:120px;border:1px solid rgba(255,0,255,0.4);border-radius:4px;overflow:hidden;z-index:15;opacity:0;transition:opacity 0.4s}
#bomb-meter.visible{opacity:1}
#bomb-fill{position:absolute;bottom:0;width:100%;background:linear-gradient(to top,#f0f,#f0f);border-radius:3px;transition:height 0.3s;box-shadow:0 0 10px #f0f}
#bomb-label{position:absolute;top:-18px;left:50%;transform:translateX(-50%);font-size:0.5rem;color:#f0f;letter-spacing:0.1em;white-space:nowrap}

/* Mute button */
#mute-btn{position:absolute;top:env(safe-area-inset-top,10px);right:15px;width:36px;height:36px;border:1px solid rgba(255,255,255,0.3);border-radius:50%;background:rgba(0,0,0,0.5);color:#fff;font-size:14px;display:flex;align-items:center;justify-content:center;pointer-events:all;cursor:pointer;z-index:25;transition:all 0.2s}
#mute-btn:active{transform:scale(0.9)}
#mute-btn.muted{border-color:rgba(255,0,0,0.5);color:#f44}

/* Game Over */
#game-over{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,0);z-index:30;opacity:0;pointer-events:none;transition:opacity 0.8s ease, background 0.8s ease}
#game-over.visible{opacity:1;pointer-events:all;background:rgba(0,0,0,0.85)}
.go-title{font-size:clamp(2rem,7vw,3.5rem);color:#f44;text-shadow:0 0 30px #f00,0 0 60px #f00;letter-spacing:0.2em;margin-bottom:0.3em;font-weight:900}
.go-score-label{font-size:clamp(0.6rem,2vw,0.8rem);color:#888;letter-spacing:0.3em;margin-top:1em}
.go-score{font-size:clamp(1.8rem,6vw,3rem);color:#0ff;text-shadow:0 0 20px #0ff;letter-spacing:0.15em;font-weight:700}
.go-best{font-size:clamp(0.7rem,2.2vw,0.9rem);color:#f0f;letter-spacing:0.2em;margin-top:0.5em;text-shadow:0 0 10px #f0f}
.go-new-best{color:#ff0;text-shadow:0 0 15px #ff0;animation:newBestPulse 1s ease-in-out infinite}
@keyframes newBestPulse{0%,100%{opacity:1}50%{opacity:0.5}}
.go-stats{font-size:clamp(0.5rem,1.5vw,0.65rem);color:#666;letter-spacing:0.15em;margin-top:0.8em;text-align:center;line-height:1.8}

/* Wave announcement */
#wave-announce{position:absolute;top:35%;left:50%;transform:translate(-50%,-50%);text-align:center;opacity:0;z-index:16;pointer-events:none;transition:none}
.wave-num{font-size:clamp(2rem,7vw,3.5rem);color:#0f0;text-shadow:0 0 30px #0f0,0 0 60px #0f0;letter-spacing:0.5em;font-weight:900}
.wave-sub{font-size:clamp(0.5rem,1.5vw,0.7rem);color:#0f0;letter-spacing:0.4em;opacity:0.6;margin-top:0.3em}

/* Touch controls */
#touch-controls{position:absolute;bottom:0;left:0;width:100%;height:45%;pointer-events:none;z-index:12;opacity:0;transition:opacity 0.3s}
#touch-controls.visible{opacity:1}
#joystick-zone{position:absolute;bottom:20px;left:20px;width:45%;height:90%;pointer-events:all}
#joystick-base{position:absolute;bottom:30px;left:30px;width:clamp(100px,25vw,140px);height:clamp(100px,25vw,140px);border:2px solid rgba(0,255,255,0.25);border-radius:50%;background:rgba(0,255,255,0.05)}
#joystick-knob{position:absolute;width:clamp(44px,10vw,56px);height:clamp(44px,10vw,56px);border:2px solid rgba(0,255,255,0.6);border-radius:50%;background:rgba(0,255,255,0.15);box-shadow:0 0 15px rgba(0,255,255,0.3);top:50%;left:50%;transform:translate(-50%,-50%);transition:box-shadow 0.2s}
#fire-btn{position:absolute;bottom:50px;right:30px;width:clamp(70px,18vw,90px);height:clamp(70px,18vw,90px);border:2px solid rgba(255,100,100,0.5);border-radius:50%;background:rgba(255,50,50,0.1);pointer-events:all;display:flex;align-items:center;justify-content:center;font-size:clamp(0.55rem,1.5vw,0.7rem);color:rgba(255,100,100,0.8);letter-spacing:0.15em;text-transform:uppercase;box-shadow:0 0 20px rgba(255,50,50,0.2);transition:all 0.1s}
#fire-btn:active{background:rgba(255,50,50,0.3);box-shadow:0 0 30px rgba(255,50,50,0.5);transform:scale(0.95)}
#bomb-btn{position:absolute;bottom:160px;right:35px;width:clamp(50px,12vw,64px);height:clamp(50px,12vw,64px);border:2px solid rgba(255,0,255,0.3);border-radius:50%;background:rgba(255,0,255,0.05);pointer-events:all;display:flex;align-items:center;justify-content:center;font-size:clamp(0.45rem,1.2vw,0.55rem);color:rgba(255,0,255,0.5);letter-spacing:0.1em;text-transform:uppercase;transition:all 0.2s}
#bomb-btn.charged{border-color:rgba(255,0,255,0.8);color:#f0f;background:rgba(255,0,255,0.15);box-shadow:0 0 25px rgba(255,0,255,0.4);animation:bombReady 1.5s ease-in-out infinite}
@keyframes bombReady{0%,100%{box-shadow:0 0 25px rgba(255,0,255,0.4)}50%{box-shadow:0 0 40px rgba(255,0,255,0.7)}}
</style>
</head>
<body>

<canvas id="bg-canvas"></canvas>
<canvas id="game-canvas"></canvas>

<div id="ui">
  <div id="title-screen">
    <div class="title-main">VECTOR SIEGE</div>
    <div class="title-sub">neon arcade shooter</div>
    <button class="play-btn" id="play-btn">PLAY</button>
    <div class="high-score-display" id="title-hi">HIGH SCORE: 0</div>
    <div class="stats-display" id="title-stats">GAMES: 0 | KILLS: 0</div>
    <div class="controls-hint" id="controls-hint"></div>
  </div>

  <div id="hud">
    <div class="hud-left">
      <div class="hud-score" id="hud-score">0</div>
      <div class="hud-hi" id="hud-hi">HI: 0</div>
    </div>
    <div class="hud-right">
      <div class="hud-wave" id="hud-wave">WAVE 1</div>
      <div class="hud-combo" id="hud-combo">x2 COMBO</div>
    </div>
  </div>

  <div id="bomb-meter">
    <div id="bomb-fill" style="height:0%"></div>
    <div id="bomb-label">BOMB</div>
  </div>

  <div id="wave-announce">
    <div class="wave-num" id="wave-num"></div>
    <div class="wave-sub" id="wave-sub"></div>
  </div>

  <div id="touch-controls">
    <div id="joystick-zone">
      <div id="joystick-base">
        <div id="joystick-knob"></div>
      </div>
    </div>
    <div id="fire-btn">FIRE</div>
    <div id="bomb-btn">BOMB</div>
  </div>

  <div id="game-over">
    <div class="go-title">GAME OVER</div>
    <div class="go-score-label">SCORE</div>
    <div class="go-score" id="go-score">0</div>
    <div class="go-best" id="go-best">BEST: 0</div>
    <div class="go-stats" id="go-stats"></div>
    <button class="play-btn" id="retry-btn" style="margin-top:2em">PLAY AGAIN</button>
  </div>

  <button id="mute-btn">♪</button>
</div>

<script>
// ============================================================
// VECTOR SIEGE — Complete Neon Arcade Shooter
// ============================================================
(function() {
'use strict';

// --- Canvas Setup ---
const bgCanvas = document.getElementById('bg-canvas');
const bgCtx = bgCanvas.getContext('2d');
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
let W, H, CX, CY, dpr = 1;

function resize() {
  dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  CX = W / 2;
  CY = H / 2;
  for (const c of [bgCanvas, canvas]) {
    c.width = W * dpr;
    c.height = H * dpr;
    c.style.width = W + 'px';
    c.style.height = H + 'px';
    c.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
  }
}
window.addEventListener('resize', resize);
resize();

// Detect touch device
const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

// Show appropriate controls hint
const controlsHint = document.getElementById('controls-hint');
if (isTouchDevice) {
  controlsHint.innerHTML = 'JOYSTICK TO MOVE • TAP TO FIRE • BOMB WHEN CHARGED';
} else {
  controlsHint.innerHTML = 'WASD / ARROWS TO MOVE • SPACE TO FIRE • B FOR BOMB';
}

// --- State ---
const STATE = { TITLE: 0, PLAYING: 1, GAME_OVER: 2 };
let state = STATE.TITLE;
let score = 0;
let displayScore = 0; // Animated score display
let wave = 1;
let bombCharge = 0;
const BOMB_CHARGE_TIME = 15;
let bombCharging = true;
let waveEnemyCount = 0;
let waveSpawnTimer = 0;
let waveSpawned = 0;
let waveDelay = 0;
let gameTime = 0;
let sessionKills = 0;

// Combo system
let comboCount = 0;
let comboTimer = 0;
const COMBO_TIMEOUT = 1.5;

// Floating score texts
let floatingTexts = [];

// Persistence
let hiScore = parseInt(localStorage.getItem('vs_hi') || '0');
let totalGames = parseInt(localStorage.getItem('vs_games') || '0');
let totalKills = parseInt(localStorage.getItem('vs_kills') || '0');

function saveStats() {
  localStorage.setItem('vs_hi', hiScore);
  localStorage.setItem('vs_games', totalGames);
  localStorage.setItem('vs_kills', totalKills);
}

// --- DOM refs ---
const titleScreen = document.getElementById('title-screen');
const playBtn = document.getElementById('play-btn');
const titleHi = document.getElementById('title-hi');
const titleStats = document.getElementById('title-stats');
const hud = document.getElementById('hud');
const hudScore = document.getElementById('hud-score');
const hudHi = document.getElementById('hud-hi');
const hudWave = document.getElementById('hud-wave');
const hudCombo = document.getElementById('hud-combo');
const bombMeter = document.getElementById('bomb-meter');
const bombFill = document.getElementById('bomb-fill');
const waveAnnounceEl = document.getElementById('wave-announce');
const waveNumEl = document.getElementById('wave-num');
const waveSubEl = document.getElementById('wave-sub');
const touchControls = document.getElementById('touch-controls');
const fireBtn = document.getElementById('fire-btn');
const bombBtn = document.getElementById('bomb-btn');
const gameOverEl = document.getElementById('game-over');
const goScore = document.getElementById('go-score');
const goBest = document.getElementById('go-best');
const goStats = document.getElementById('go-stats');
const retryBtn = document.getElementById('retry-btn');
const muteBtn = document.getElementById('mute-btn');
const joystickBase = document.getElementById('joystick-base');
const joystickKnob = document.getElementById('joystick-knob');
const joystickZone = document.getElementById('joystick-zone');

// --- Audio Engine ---
let audioCtx = null;
let masterGain = null;
let musicGain = null;
let sfxGain = null;
let muted = false;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 1;
  masterGain.connect(audioCtx.destination);
  musicGain = audioCtx.createGain();
  musicGain.gain.value = 0.22;
  musicGain.connect(masterGain);
  sfxGain = audioCtx.createGain();
  sfxGain.gain.value = 0.45;
  sfxGain.connect(masterGain);
}

function toggleMute() {
  muted = !muted;
  muteBtn.textContent = muted ? '✕' : '♪';
  muteBtn.classList.toggle('muted', muted);
  if (masterGain) masterGain.gain.value = muted ? 0 : 1;
}

muteBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleMute(); });
muteBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); toggleMute(); });

// --- Sound Effects ---
function playThrustSound() {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'sawtooth';
  osc.frequency.value = 55 + Math.random() * 10;
  g.gain.setValueAtTime(0.1, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.12);
  osc.connect(g); g.connect(sfxGain);
  osc.start(); osc.stop(audioCtx.currentTime + 0.12);
}

function playFireSound() {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.08);
  g.gain.setValueAtTime(0.15, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
  osc.connect(g); g.connect(sfxGain);
  osc.start(); osc.stop(audioCtx.currentTime + 0.1);
  // Add a higher harmonic for "pew" character
  const osc2 = audioCtx.createOscillator();
  const g2 = audioCtx.createGain();
  osc2.type = 'sine';
  osc2.frequency.setValueAtTime(2400, audioCtx.currentTime);
  osc2.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.06);
  g2.gain.setValueAtTime(0.08, audioCtx.currentTime);
  g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.06);
  osc2.connect(g2); g2.connect(sfxGain);
  osc2.start(); osc2.stop(audioCtx.currentTime + 0.08);
}

function playExplosionSound(big) {
  if (!audioCtx) return;
  const dur = big ? 0.35 : 0.18;
  const bufSize = audioCtx.sampleRate * dur;
  const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) {
    d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufSize, 1.5);
  }
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  const g = audioCtx.createGain();
  g.gain.setValueAtTime(big ? 0.35 : 0.22, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  const f = audioCtx.createBiquadFilter();
  f.type = 'lowpass';
  f.frequency.value = big ? 500 : 1000;
  src.connect(f); f.connect(g); g.connect(sfxGain);
  src.start();
}

function playBombSound() {
  if (!audioCtx) return;
  const dur = 1.0;
  const bufSize = audioCtx.sampleRate * dur;
  const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) {
    const t = i / audioCtx.sampleRate;
    d[i] = (Math.random() * 2 - 1) * Math.exp(-t * 3) * (0.5 + 0.5 * Math.sin(t * 50));
  }
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.5, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  const f = audioCtx.createBiquadFilter();
  f.type = 'lowpass'; f.frequency.value = 250;
  src.connect(f); f.connect(g); g.connect(sfxGain);
  src.start();
  // Sub
  const osc = audioCtx.createOscillator();
  const og = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(60, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.7);
  og.gain.setValueAtTime(0.45, audioCtx.currentTime);
  og.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.7);
  osc.connect(og); og.connect(sfxGain);
  osc.start(); osc.stop(audioCtx.currentTime + 0.7);
}

function playDeathSound() {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(440, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(35, audioCtx.currentTime + 1.2);
  g.gain.setValueAtTime(0.3, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);
  osc.connect(g); g.connect(sfxGain);
  osc.start(); osc.stop(audioCtx.currentTime + 1.2);
  const bufSize = audioCtx.sampleRate * 0.6;
  const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / bufSize) * 0.4;
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  const ng = audioCtx.createGain();
  ng.gain.setValueAtTime(0.25, audioCtx.currentTime);
  ng.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
  src.connect(ng); ng.connect(sfxGain);
  src.start();
}

function playComboSound(combo) {
  if (!audioCtx) return;
  const freq = 440 + combo * 80;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  osc.frequency.setValueAtTime(freq * 1.5, audioCtx.currentTime + 0.05);
  g.gain.setValueAtTime(0.12, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
  osc.connect(g); g.connect(sfxGain);
  osc.start(); osc.stop(audioCtx.currentTime + 0.15);
}

function playWaveSound() {
  if (!audioCtx) return;
  [0, 0.1, 0.2].forEach((delay, i) => {
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'sine';
    const freq = [330, 440, 660][i];
    osc.frequency.value = freq;
    const t = audioCtx.currentTime + delay;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.15, t + 0.03);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
    osc.connect(g); g.connect(sfxGain);
    osc.start(t); osc.stop(t + 0.3);
  });
}

// --- Music ---
let musicPlaying = false;
let musicNodes = [];

function startMusic() {
  if (!audioCtx || musicPlaying) return;
  musicPlaying = true;
  const bpm = 128;
  const beatLen = 60 / bpm;
  const barLen = beatLen * 4;
  const bassNotes = [55, 55, 73.4, 65.4, 55, 55, 82.4, 73.4];

  function scheduleBassLoop(startTime) {
    bassNotes.forEach((freq, i) => {
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      osc.type = 'sawtooth';
      osc.frequency.value = freq;
      filter.type = 'lowpass'; filter.frequency.value = 400; filter.Q.value = 8;
      const t = startTime + i * beatLen;
      filter.frequency.setValueAtTime(200, t);
      filter.frequency.linearRampToValueAtTime(600, t + beatLen * 0.3);
      filter.frequency.linearRampToValueAtTime(200, t + beatLen * 0.8);
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.35, t + 0.02);
      g.gain.setValueAtTime(0.35, t + beatLen * 0.7);
      g.gain.linearRampToValueAtTime(0, t + beatLen * 0.95);
      osc.connect(filter); filter.connect(g); g.connect(musicGain);
      osc.start(t); osc.stop(t + beatLen);
      musicNodes.push(osc);
    });
  }

  function scheduleArpLoop(startTime) {
    const arpNotes = [220, 330, 440, 330, 261.6, 392, 523.2, 392];
    arpNotes.forEach((freq, i) => {
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'triangle';
      osc.frequency.value = freq;
      const t = startTime + i * beatLen * 0.5;
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.07, t + 0.02);
      g.gain.setValueAtTime(0.07, t + beatLen * 0.3);
      g.gain.linearRampToValueAtTime(0, t + beatLen * 0.48);
      osc.connect(g); g.connect(musicGain);
      osc.start(t); osc.stop(t + beatLen * 0.5);
      musicNodes.push(osc);
    });
  }

  function scheduleKickLoop(startTime) {
    for (let i = 0; i < 8; i++) {
      const t = startTime + i * beatLen;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, t);
      osc.frequency.exponentialRampToValueAtTime(30, t + 0.12);
      g.gain.setValueAtTime(0.35, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
      osc.connect(g); g.connect(musicGain);
      osc.start(t); osc.stop(t + 0.15);
      musicNodes.push(osc);
    }
  }

  function scheduleHatLoop(startTime) {
    for (let i = 0; i < 16; i++) {
      const t = startTime + i * beatLen * 0.5;
      const bufSize = audioCtx.sampleRate * 0.04;
      const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
      const d = buf.getChannelData(0);
      for (let j = 0; j < bufSize; j++) d[j] = (Math.random() * 2 - 1) * (1 - j / bufSize);
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(i % 2 === 0 ? 0.06 : 0.03, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.04);
      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass'; hp.frequency.value = 8000;
      src.connect(hp); hp.connect(g); g.connect(musicGain);
      src.start(t); musicNodes.push(src);
    }
  }

  let loopTime = audioCtx.currentTime + 0.1;
  let loopId;

  function scheduleLoop() {
    if (!musicPlaying) return;
    scheduleBassLoop(loopTime);
    scheduleArpLoop(loopTime);
    scheduleKickLoop(loopTime);
    scheduleHatLoop(loopTime);
    loopTime += barLen * 2;
    loopId = setTimeout(scheduleLoop, (barLen * 2 - 1) * 1000);
  }
  scheduleLoop();
  musicNodes._loopId = loopId;
}

function stopMusic() {
  musicPlaying = false;
  if (musicNodes._loopId) clearTimeout(musicNodes._loopId);
  musicNodes.forEach(n => { try { n.stop(); } catch(e) {} });
  musicNodes = [];
}

// --- Utility ---
function rand(a, b) { return a + Math.random() * (b - a); }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function angleToTarget(sx, sy, tx, ty) { return Math.atan2(ty - sy, tx - sx); }

function setGlow(c, color, blur) { c.shadowColor = color; c.shadowBlur = blur; }
function clearGlow(c) { c.shadowColor = 'transparent'; c.shadowBlur = 0; }

// --- Grid Background ---
const gridSpacing = 50;
let gridDistortions = [];

function addGridDistortion(x, y, strength) {
  gridDistortions.push({ x, y, maxStrength: strength, life: 1 });
}

function updateGrid(dt) {
  for (let i = gridDistortions.length - 1; i >= 0; i--) {
    gridDistortions[i].life -= dt * 1.5;
    if (gridDistortions[i].life <= 0) gridDistortions.splice(i, 1);
  }
}

function drawGrid() {
  bgCtx.clearRect(0, 0, W, H);
  bgCtx.strokeStyle = 'rgba(0,255,255,0.055)';
  bgCtx.lineWidth = 0.5;

  for (let y = 0; y < H; y += gridSpacing) {
    bgCtx.beginPath();
    for (let x = 0; x <= W; x += 10) {
      let dy = 0;
      for (const d of gridDistortions) {
        const dd = dist(x, y, d.x, d.y);
        if (dd < 200) {
          const falloff = 1 - dd / 200;
          dy += Math.sin(dd * 0.05 + d.life * 10) * d.maxStrength * d.life * falloff * 8;
        }
      }
      if (x === 0) bgCtx.moveTo(x, y + dy);
      else bgCtx.lineTo(x, y + dy);
    }
    bgCtx.stroke();
  }

  for (let x = 0; x < W; x += gridSpacing) {
    bgCtx.beginPath();
    for (let y = 0; y <= H; y += 10) {
      let dx = 0;
      for (const d of gridDistortions) {
        const dd = dist(x, y, d.x, d.y);
        if (dd < 200) {
          const falloff = 1 - dd / 200;
          dx += Math.sin(dd * 0.05 + d.life * 10) * d.maxStrength * d.life * falloff * 8;
        }
      }
      if (y === 0) bgCtx.moveTo(x + dx, y);
      else bgCtx.lineTo(x + dx, y);
    }
    bgCtx.stroke();
  }
}

// --- Screen Shake ---
let shakeAmount = 0;
let shakeX = 0, shakeY = 0;
let flashAlpha = 0;
let flashColor = '#fff';

function addShake(amount) { shakeAmount = Math.max(shakeAmount, amount); }
function addFlash(alpha, color) { flashAlpha = Math.max(flashAlpha, alpha); flashColor = color || '#fff'; }

function updateShake(dt) {
  if (shakeAmount > 0.1) {
    shakeX = (Math.random() - 0.5) * shakeAmount;
    shakeY = (Math.random() - 0.5) * shakeAmount;
    shakeAmount *= 0.82;
  } else {
    shakeX = shakeY = 0;
    shakeAmount = 0;
  }
  if (flashAlpha > 0) flashAlpha = Math.max(0, flashAlpha - dt * 4);
}

// --- Particles ---
let particles = [];

function spawnParticles(x, y, color, count, speed, life) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const sp = rand(speed * 0.3, speed);
    particles.push({ x, y, vx: Math.cos(angle) * sp, vy: Math.sin(angle) * sp, life: rand(life * 0.5, life), maxLife: life, color, size: rand(1, 3.5) });
  }
}

function spawnDebris(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const sp = rand(30, 180);
    particles.push({ x, y, vx: Math.cos(angle) * sp, vy: Math.sin(angle) * sp, life: rand(0.3, 0.9), maxLife: 0.9, color, size: 1.5, isLine: true, angle, len: rand(4, 14), rot: rand(-6, 6) });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= 0.97;
    p.vy *= 0.97;
    p.life -= dt;
    if (p.isLine) p.angle += p.rot * dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    const alpha = clamp(p.life / p.maxLife, 0, 1);
    ctx.globalAlpha = alpha;
    if (p.isLine) {
      ctx.strokeStyle = p.color;
      ctx.lineWidth = p.size;
      setGlow(ctx, p.color, 6);
      ctx.beginPath();
      ctx.moveTo(p.x - Math.cos(p.angle) * p.len * 0.5, p.y - Math.sin(p.angle) * p.len * 0.5);
      ctx.lineTo(p.x + Math.cos(p.angle) * p.len * 0.5, p.y + Math.sin(p.angle) * p.len * 0.5);
      ctx.stroke();
    } else {
      setGlow(ctx, p.color, 8);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
  clearGlow(ctx);
}

// --- Floating Score Texts ---
function addFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 1.0, vy: -60 });
}

function updateFloatingTexts(dt) {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const ft = floatingTexts[i];
    ft.y += ft.vy * dt;
    ft.vy *= 0.95;
    ft.life -= dt * 1.2;
    if (ft.life <= 0) floatingTexts.splice(i, 1);
  }
}

function drawFloatingTexts() {
  for (const ft of floatingTexts) {
    ctx.globalAlpha = clamp(ft.life, 0, 1);
    ctx.font = `bold ${Math.max(10, 12 + ft.text.length)}px 'Courier New', monospace`;
    ctx.textAlign = 'center';
    setGlow(ctx, ft.color, 10);
    ctx.fillStyle = ft.color;
    ctx.fillText(ft.text, ft.x, ft.y);
  }
  ctx.globalAlpha = 1;
  clearGlow(ctx);
}

// --- Player Ship ---
const ship = {
  x: 0, y: 0, vx: 0, vy: 0,
  angle: -Math.PI / 2,
  radius: 14,
  thrusting: false, thrustPower: 0,
  dead: false, invincible: 0,
  fireTimer: 0, fireRate: 0.13,
};

function resetShip() {
  ship.x = CX; ship.y = CY;
  ship.vx = 0; ship.vy = 0;
  ship.angle = -Math.PI / 2;
  ship.thrusting = false; ship.thrustPower = 0;
  ship.dead = false; ship.invincible = 3;
  ship.fireTimer = 0;
}

let thrustSoundTimer = 0;

function updateShip(dt) {
  if (ship.dead) return;
  ship.invincible = Math.max(0, ship.invincible - dt);
  ship.fireTimer = Math.max(0, ship.fireTimer - dt);

  if (joystickActive) {
    const jAngle = Math.atan2(joystickDY, joystickDX);
    const jMag = Math.min(1, Math.hypot(joystickDX, joystickDY));
    let angleDiff = jAngle - ship.angle;
    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
    ship.angle += angleDiff * Math.min(1, dt * 12);
    ship.thrustPower = jMag;
    ship.thrusting = jMag > 0.15;
  } else if (keys.left || keys.right || keys.up) {
    if (keys.left) ship.angle -= 4.5 * dt;
    if (keys.right) ship.angle += 4.5 * dt;
    ship.thrusting = keys.up;
    ship.thrustPower = keys.up ? 1 : 0;
  } else {
    ship.thrusting = false;
    ship.thrustPower = 0;
  }

  if (ship.thrusting) {
    const thrust = 340 * ship.thrustPower;
    ship.vx += Math.cos(ship.angle) * thrust * dt;
    ship.vy += Math.sin(ship.angle) * thrust * dt;
    thrustSoundTimer -= dt;
    if (thrustSoundTimer <= 0) { playThrustSound(); thrustSoundTimer = 0.12; }
    if (Math.random() < ship.thrustPower) {
      const bx = ship.x - Math.cos(ship.angle) * 14;
      const by = ship.y - Math.sin(ship.angle) * 14;
      spawnParticles(bx, by, '#0ff', 1, 70 * ship.thrustPower, 0.4);
    }
  }

  ship.vx *= (1 - 1.3 * dt);
  ship.vy *= (1 - 1.3 * dt);

  const sp = Math.hypot(ship.vx, ship.vy);
  const maxSpeed = 300;
  if (sp > maxSpeed) { ship.vx = (ship.vx / sp) * maxSpeed; ship.vy = (ship.vy / sp) * maxSpeed; }

  ship.x += ship.vx * dt;
  ship.y += ship.vy * dt;

  const margin = 20;
  if (ship.x < -margin) ship.x = W + margin;
  if (ship.x > W + margin) ship.x = -margin;
  if (ship.y < -margin) ship.y = H + margin;
  if (ship.y > H + margin) ship.y = -margin;

  if (keys.space && ship.fireTimer <= 0) { fireProjectile(); ship.fireTimer = ship.fireRate; }
}

function drawShip() {
  if (ship.dead) return;
  if (ship.invincible > 0 && Math.floor(ship.invincible * 8) % 2) return;

  ctx.save();
  ctx.translate(ship.x, ship.y);
  ctx.rotate(ship.angle);
  const r = ship.radius;

  // Shield glow when invincible
  if (ship.invincible > 0) {
    ctx.globalAlpha = 0.15 + Math.sin(ship.invincible * 15) * 0.1;
    setGlow(ctx, '#0ff', 25);
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, 0, r * 1.8, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  setGlow(ctx, '#0ff', 15);
  ctx.strokeStyle = '#0ff';
  ctx.lineWidth = 2;
  ctx.fillStyle = 'rgba(0,255,255,0.08)';

  ctx.beginPath();
  ctx.moveTo(r * 1.2, 0);
  ctx.lineTo(-r * 0.8, -r * 0.7);
  ctx.lineTo(-r * 0.4, 0);
  ctx.lineTo(-r * 0.8, r * 0.7);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.strokeStyle = 'rgba(0,255,255,0.4)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(r * 0.6, 0);
  ctx.lineTo(-r * 0.2, -r * 0.3);
  ctx.lineTo(-r * 0.2, r * 0.3);
  ctx.closePath();
  ctx.stroke();

  if (ship.thrusting) {
    const flicker = rand(0.6, 1.0) * ship.thrustPower;
    ctx.strokeStyle = `rgba(255,${Math.floor(100 + flicker * 155)},0,${flicker})`;
    ctx.lineWidth = 2;
    setGlow(ctx, '#f80', 12);
    ctx.beginPath();
    ctx.moveTo(-r * 0.5, -r * 0.35);
    ctx.lineTo(-r * (0.8 + flicker * 0.7), 0);
    ctx.lineTo(-r * 0.5, r * 0.35);
    ctx.stroke();
  }

  clearGlow(ctx);
  ctx.restore();
}

// --- Projectiles ---
let projectiles = [];

function fireProjectile() {
  if (ship.dead) return;
  playFireSound();
  const speed = 520;
  projectiles.push({
    x: ship.x + Math.cos(ship.angle) * ship.radius * 1.3,
    y: ship.y + Math.sin(ship.angle) * ship.radius * 1.3,
    vx: Math.cos(ship.angle) * speed + ship.vx * 0.3,
    vy: Math.sin(ship.angle) * speed + ship.vy * 0.3,
    life: 1.3,
  });
}

function updateProjectiles(dt) {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= dt;
    if (p.life <= 0 || p.x < -20 || p.x > W + 20 || p.y < -20 || p.y > H + 20) {
      projectiles.splice(i, 1);
    }
  }
}

function drawProjectiles() {
  for (const p of projectiles) {
    const alpha = clamp(p.life / 0.3, 0, 1);
    ctx.globalAlpha = alpha;
    setGlow(ctx, '#ff0', 14);
    ctx.strokeStyle = '#ff0';
    ctx.lineWidth = 2.5;
    const len = 10;
    const angle = Math.atan2(p.vy, p.vx);
    ctx.beginPath();
    ctx.moveTo(p.x - Math.cos(angle) * len, p.y - Math.sin(angle) * len);
    ctx.lineTo(p.x + Math.cos(angle) * len, p.y + Math.sin(angle) * len);
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  clearGlow(ctx);
}

// --- Enemies ---
let enemies = [];

const ENEMY_TYPES = {
  SQUARE:       { sides: 4, color: '#f44', glow: '#f00', size: 18, speed: 50, hp: 1, score: 100, splitN: 2, splitType: 'SMALL_SQUARE' },
  SMALL_SQUARE: { sides: 4, color: '#f84', glow: '#f40', size: 10, speed: 80, hp: 1, score: 50, splitN: 0 },
  PENTAGON:     { sides: 5, color: '#f0f', glow: '#f0f', size: 22, speed: 40, hp: 2, score: 200, splitN: 3, splitType: 'TRIANGLE' },
  TRIANGLE:     { sides: 3, color: '#fa0', glow: '#f80', size: 10, speed: 90, hp: 1, score: 75, splitN: 0 },
  HEXAGON:      { sides: 6, color: '#4f4', glow: '#0f0', size: 26, speed: 30, hp: 3, score: 350, splitN: 2, splitType: 'SQUARE' },
  DIAMOND:      { sides: 4, color: '#4ff', glow: '#0ff', size: 14, speed: 120, hp: 1, score: 150, splitN: 0, isDiamond: true },
};

function spawnEnemy(typeName, x, y) {
  const type = ENEMY_TYPES[typeName];
  if (!type) return;

  if (x === undefined) {
    const side = randInt(0, 3);
    switch (side) {
      case 0: x = rand(0, W); y = -30; break;
      case 1: x = W + 30; y = rand(0, H); break;
      case 2: x = rand(0, W); y = H + 30; break;
      case 3: x = -30; y = rand(0, H); break;
    }
  }

  const targetX = CX + rand(-W * 0.3, W * 0.3);
  const targetY = CY + rand(-H * 0.3, H * 0.3);
  const angle = angleToTarget(x, y, targetX, targetY);
  const waveSpeedMult = 1 + (wave - 1) * 0.07;
  const sp = type.speed * rand(0.8, 1.2) * waveSpeedMult;

  enemies.push({
    x, y,
    vx: Math.cos(angle) * sp, vy: Math.sin(angle) * sp,
    angle: Math.random() * Math.PI * 2,
    rotSpeed: rand(-2, 2),
    radius: type.size,
    sides: type.sides,
    color: type.color,
    glowColor: type.glow,
    hp: type.hp, maxHp: type.hp,
    score: type.score,
    splitN: type.splitN,
    splitType: type.splitType,
    isDiamond: type.isDiamond,
    typeName,
    hitFlash: 0,
    pulsePhase: Math.random() * Math.PI * 2,
  });
}

function updateEnemies(dt) {
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    e.x += e.vx * dt;
    e.y += e.vy * dt;
    e.angle += e.rotSpeed * dt;
    e.hitFlash = Math.max(0, e.hitFlash - dt * 5);
    e.pulsePhase += dt * 3;

    if (!ship.dead) {
      const toPlayer = angleToTarget(e.x, e.y, ship.x, ship.y);
      const sp = Math.hypot(e.vx, e.vy);
      const curAngle = Math.atan2(e.vy, e.vx);
      let diff = toPlayer - curAngle;
      while (diff > Math.PI) diff -= Math.PI * 2;
      while (diff < -Math.PI) diff += Math.PI * 2;
      const homingStrength = wave <= 1 ? 0.1 : 0.2 + wave * 0.025;
      const newAngle = curAngle + diff * homingStrength * dt;
      e.vx = Math.cos(newAngle) * sp;
      e.vy = Math.sin(newAngle) * sp;
    }

    if (e.x < -120 || e.x > W + 120 || e.y < -120 || e.y > H + 120) {
      enemies.splice(i, 1);
    }
  }
}

function drawPolygon(cx, cy, radius, sides, angle, isDiamond) {
  ctx.beginPath();
  for (let i = 0; i <= sides; i++) {
    let a = angle + (i / sides) * Math.PI * 2;
    let r = radius;
    if (isDiamond && i < sides) r = (i % 2 === 0) ? radius * 1.3 : radius * 0.7;
    const px = cx + Math.cos(a) * r;
    const py = cy + Math.sin(a) * r;
    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.closePath();
}

function drawEnemies() {
  for (const e of enemies) {
    ctx.save();
    const flash = e.hitFlash > 0;
    const color = flash ? '#fff' : e.color;
    const glow = flash ? '#fff' : e.glowColor;
    const pulse = 1 + Math.sin(e.pulsePhase) * 0.05;
    const drawRadius = e.radius * pulse;

    setGlow(ctx, glow, flash ? 20 : 12);
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.fillStyle = flash ? 'rgba(255,255,255,0.25)' : `${e.color}12`;

    drawPolygon(e.x, e.y, drawRadius, e.sides, e.angle, e.isDiamond);
    ctx.fill();
    ctx.stroke();

    if (e.maxHp > 1) {
      clearGlow(ctx);
      ctx.strokeStyle = `rgba(255,255,255,${0.15 + (e.hp / e.maxHp) * 0.2})`;
      ctx.lineWidth = 1;
      const innerR = drawRadius * 0.5 * (e.hp / e.maxHp);
      drawPolygon(e.x, e.y, innerR, e.sides, -e.angle * 0.5, e.isDiamond);
      ctx.stroke();
    }

    clearGlow(ctx);
    ctx.restore();
  }
}

// --- Collision ---
function checkCollisions() {
  for (let pi = projectiles.length - 1; pi >= 0; pi--) {
    const p = projectiles[pi];
    for (let ei = enemies.length - 1; ei >= 0; ei--) {
      const e = enemies[ei];
      if (dist(p.x, p.y, e.x, e.y) < e.radius + 6) {
        projectiles.splice(pi, 1);
        e.hp--;
        e.hitFlash = 1;
        if (e.hp <= 0) {
          destroyEnemy(e, ei);
        } else {
          spawnParticles(p.x, p.y, e.color, 5, 80, 0.3);
          playExplosionSound(false);
        }
        break;
      }
    }
  }

  if (!ship.dead && ship.invincible <= 0) {
    for (const e of enemies) {
      if (dist(ship.x, ship.y, e.x, e.y) < ship.radius + e.radius - 4) {
        killPlayer();
        break;
      }
    }
  }
}

function destroyEnemy(e, idx) {
  enemies.splice(idx, 1);

  // Combo
  comboCount++;
  comboTimer = COMBO_TIMEOUT;
  const comboMult = Math.min(comboCount, 8);
  const points = e.score * comboMult;
  score += points;
  sessionKills++;
  totalKills++;

  // Floating score text
  const comboText = comboMult > 1 ? `+${points} x${comboMult}` : `+${points}`;
  const comboColor = comboMult >= 5 ? '#f0f' : comboMult >= 3 ? '#ff0' : '#fff';
  addFloatingText(e.x, e.y - 10, comboText, comboColor);
  if (comboMult >= 3) playComboSound(comboMult);

  spawnParticles(e.x, e.y, e.color, 18, 140, 0.7);
  spawnDebris(e.x, e.y, e.color, 7);
  addGridDistortion(e.x, e.y, e.radius / 14);
  addShake(5);

  playExplosionSound(e.radius > 20);

  if (e.splitN > 0 && e.splitType) {
    for (let i = 0; i < e.splitN; i++) {
      const offsetAngle = (i / e.splitN) * Math.PI * 2 + Math.random() * 0.5;
      spawnEnemy(e.splitType, e.x + Math.cos(offsetAngle) * 15, e.y + Math.sin(offsetAngle) * 15);
    }
  }
}

let deathTimeout = null;

function killPlayer() {
  ship.dead = true;
  spawnParticles(ship.x, ship.y, '#0ff', 50, 220, 1.0);
  spawnParticles(ship.x, ship.y, '#fff', 20, 150, 0.6);
  spawnDebris(ship.x, ship.y, '#0ff', 15);
  addGridDistortion(ship.x, ship.y, 3.5);
  addShake(25);
  addFlash(0.7, '#f44');
  playDeathSound();
  if (deathTimeout) clearTimeout(deathTimeout);
  deathTimeout = setTimeout(() => { deathTimeout = null; showGameOver(); }, 1800);
}

// --- Smart Bomb ---
function activateBomb() {
  if (bombCharge < 1 || ship.dead) return;
  bombCharge = 0;
  playBombSound();
  addShake(18);
  addFlash(0.9, '#f0f');
  addGridDistortion(CX, CY, 4);

  spawnParticles(ship.x, ship.y, '#fff', 60, 350, 0.8);
  spawnParticles(ship.x, ship.y, '#f0f', 40, 280, 0.6);

  let bombScore = 0;
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    bombScore += e.score;
    sessionKills++;
    totalKills++;
    spawnParticles(e.x, e.y, e.color, 10, 120, 0.5);
    spawnDebris(e.x, e.y, e.color, 4);
  }
  score += bombScore;
  if (bombScore > 0) addFloatingText(CX, CY - 50, `BOMB +${bombScore}`, '#f0f');
  enemies.length = 0;
  bombRings.push({ x: ship.x, y: ship.y, radius: 0, life: 1 });
}

let bombRings = [];

function updateBombRings(dt) {
  for (let i = bombRings.length - 1; i >= 0; i--) {
    const r = bombRings[i];
    r.radius += 650 * dt;
    r.life -= dt * 1.4;
    if (r.life <= 0) bombRings.splice(i, 1);
  }
}

function drawBombRings() {
  for (const r of bombRings) {
    const w = 3 + (1 - r.life) * 12;
    ctx.strokeStyle = `rgba(255,0,255,${r.life * 0.5})`;
    ctx.lineWidth = w;
    setGlow(ctx, '#f0f', 25);
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
    ctx.stroke();
    // Second thinner ring
    ctx.strokeStyle = `rgba(255,255,255,${r.life * 0.3})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.radius * 0.8, 0, Math.PI * 2);
    ctx.stroke();
    clearGlow(ctx);
  }
}

// --- Wave System ---
const waveMessages = [
  '', 'INCOMING', 'STAY SHARP', 'THEY MULTIPLY', 'FAST MOVERS',
  'HEAVY ARMOR', 'DANGER ZONE', 'NO MERCY', 'OVERWHELMING', 'ONSLAUGHT', 'ENDLESS'
];

function startWave(n) {
  wave = n;
  waveDelay = n === 1 ? 3.0 : 2.5;

  if (n <= 3) waveEnemyCount = 3 + n * 2;
  else if (n <= 6) waveEnemyCount = 6 + n * 3;
  else waveEnemyCount = 10 + n * 3;

  waveSpawned = 0;
  waveSpawnTimer = 0;
  announceWave(n);
}

function announceWave(n) {
  playWaveSound();
  waveNumEl.textContent = `WAVE ${n}`;
  waveSubEl.textContent = waveMessages[Math.min(n, waveMessages.length - 1)] || 'SURVIVE';
  waveAnnounceEl.style.opacity = '1';
  waveAnnounceEl.style.transform = 'translate(-50%, -50%) scale(1.3)';
  waveAnnounceEl.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
  setTimeout(() => {
    waveAnnounceEl.style.opacity = '1';
    waveAnnounceEl.style.transform = 'translate(-50%, -50%) scale(1)';
  }, 100);
  setTimeout(() => {
    waveAnnounceEl.style.transition = 'opacity 1.2s ease-in, transform 1.2s ease-in';
    waveAnnounceEl.style.opacity = '0';
    waveAnnounceEl.style.transform = 'translate(-50%, -50%) scale(0.7)';
  }, 1500);
}

function getEnemyTypeForWave() {
  const types = ['SQUARE'];
  if (wave >= 2) types.push('TRIANGLE', 'SQUARE');
  if (wave >= 3) types.push('PENTAGON', 'DIAMOND');
  if (wave >= 4) types.push('DIAMOND');
  if (wave >= 5) types.push('HEXAGON');
  if (wave >= 7) types.push('HEXAGON', 'PENTAGON');
  return types[randInt(0, types.length - 1)];
}

function updateWaves(dt) {
  if (ship.dead) return;

  if (waveDelay > 0) { waveDelay -= dt; return; }

  if (waveSpawned < waveEnemyCount) {
    waveSpawnTimer -= dt;
    const spawnInterval = Math.max(0.15, 1.8 - wave * 0.1);
    if (waveSpawnTimer <= 0) {
      spawnEnemy(getEnemyTypeForWave());
      waveSpawned++;
      waveSpawnTimer = spawnInterval;
    }
  }

  if (waveSpawned >= waveEnemyCount && enemies.length === 0) {
    startWave(wave + 1);
  }
}

// --- Input ---
const keys = { left: false, right: false, up: false, space: false };

document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
  if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
  if (e.key === 'ArrowUp' || e.key === 'w') keys.up = true;
  if (e.key === ' ') { keys.space = true; e.preventDefault(); }
  if (e.key === 'b' || e.key === 'B') activateBomb();
  // Quick restart on Enter from game over
  if (e.key === 'Enter' && state === STATE.GAME_OVER) startGame();
  if (e.key === 'Enter' && state === STATE.TITLE) startGame();
});
document.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
  if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
  if (e.key === 'ArrowUp' || e.key === 'w') keys.up = false;
  if (e.key === ' ') keys.space = false;
});

// --- Touch Joystick ---
let joystickActive = false;
let joystickDX = 0, joystickDY = 0;
let joystickTouchId = null;
let joystickCenterX = 0, joystickCenterY = 0;
let fireTouchId = null;
let fireHeld = false;

const joystickMaxDist = 50;

joystickZone.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (joystickTouchId !== null) return;
  const touch = e.changedTouches[0];
  joystickTouchId = touch.identifier;
  const rect = joystickBase.getBoundingClientRect();
  joystickCenterX = rect.left + rect.width / 2;
  joystickCenterY = rect.top + rect.height / 2;
  updateJoystickPosition(touch);
  joystickActive = true;
}, { passive: false });

document.addEventListener('touchmove', (e) => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystickTouchId) {
      e.preventDefault();
      updateJoystickPosition(touch);
    }
  }
}, { passive: false });

document.addEventListener('touchend', (e) => {
  for (const touch of e.changedTouches) {
    if (touch.identifier === joystickTouchId) {
      joystickTouchId = null;
      joystickActive = false;
      joystickDX = 0; joystickDY = 0;
      joystickKnob.style.transform = 'translate(-50%, -50%)';
    }
    if (touch.identifier === fireTouchId) {
      fireTouchId = null;
      fireHeld = false;
    }
  }
});

function updateJoystickPosition(touch) {
  let dx = touch.clientX - joystickCenterX;
  let dy = touch.clientY - joystickCenterY;
  const d = Math.hypot(dx, dy);
  if (d > joystickMaxDist) { dx = (dx / d) * joystickMaxDist; dy = (dy / d) * joystickMaxDist; }
  joystickDX = dx / joystickMaxDist;
  joystickDY = dy / joystickMaxDist;
  joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
}

fireBtn.addEventListener('touchstart', (e) => {
  e.preventDefault();
  fireTouchId = e.changedTouches[0].identifier;
  fireHeld = true;
}, { passive: false });

bombBtn.addEventListener('touchstart', (e) => {
  e.preventDefault();
  activateBomb();
}, { passive: false });

// --- Game State ---
function showTitle() {
  state = STATE.TITLE;
  titleHi.textContent = `HIGH SCORE: ${hiScore.toLocaleString()}`;
  titleStats.textContent = `GAMES: ${totalGames} | KILLS: ${totalKills}`;
  titleScreen.classList.remove('hidden');
  hud.classList.remove('visible');
  bombMeter.classList.remove('visible');
  gameOverEl.classList.remove('visible');
  touchControls.classList.remove('visible');
  enemies.length = 0;
  projectiles.length = 0;
  particles.length = 0;
  bombRings.length = 0;
  floatingTexts.length = 0;
}

function startGame() {
  // Cancel any pending death timeout from previous game
  if (deathTimeout) { clearTimeout(deathTimeout); deathTimeout = null; }

  initAudio();
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  startMusic();

  state = STATE.PLAYING;
  score = 0; displayScore = 0;
  wave = 0; bombCharge = 0;
  bombCharging = true;
  sessionKills = 0; gameTime = 0;
  comboCount = 0; comboTimer = 0;

  enemies.length = 0;
  projectiles.length = 0;
  particles.length = 0;
  bombRings.length = 0;
  floatingTexts.length = 0;

  resetShip();
  startWave(1);

  titleScreen.classList.add('hidden');
  gameOverEl.classList.remove('visible');
  hud.classList.add('visible');
  bombMeter.classList.add('visible');
  touchControls.classList.add('visible');
}

function showGameOver() {
  state = STATE.GAME_OVER;
  stopMusic();

  const isNewBest = score > hiScore;
  if (isNewBest) hiScore = score;
  totalGames++;
  saveStats();

  goScore.textContent = score.toLocaleString();
  goBest.textContent = isNewBest ? 'NEW HIGH SCORE!' : `BEST: ${hiScore.toLocaleString()}`;
  goBest.className = 'go-best' + (isNewBest ? ' go-new-best' : '');
  goStats.innerHTML = `WAVE ${wave} | ${sessionKills} KILLS<br>TOTAL GAMES: ${totalGames} | TOTAL KILLS: ${totalKills}`;

  gameOverEl.classList.add('visible');
  touchControls.classList.remove('visible');
}

playBtn.addEventListener('click', startGame);
playBtn.addEventListener('touchend', (e) => { e.preventDefault(); startGame(); });
retryBtn.addEventListener('click', startGame);
retryBtn.addEventListener('touchend', (e) => { e.preventDefault(); startGame(); });

// --- Title Background ---
let titleParticles = [];

function initTitleParticles() {
  titleParticles = [];
  const colors = ['#0ff', '#f0f', '#ff0', '#0f0', '#f44'];
  for (let i = 0; i < 30; i++) {
    titleParticles.push({
      x: rand(0, W), y: rand(0, H),
      vx: rand(-15, 15), vy: rand(-15, 15),
      angle: rand(0, Math.PI * 2),
      rotSpeed: rand(-1, 1),
      radius: rand(8, 25),
      sides: randInt(3, 6),
      color: colors[randInt(0, colors.length - 1)],
      alpha: rand(0.1, 0.3),
    });
  }
}

function updateTitleParticles(dt) {
  for (const p of titleParticles) {
    p.x += p.vx * dt; p.y += p.vy * dt;
    p.angle += p.rotSpeed * dt;
    if (p.x < -30) p.x = W + 30;
    if (p.x > W + 30) p.x = -30;
    if (p.y < -30) p.y = H + 30;
    if (p.y > H + 30) p.y = -30;
  }
}

function drawTitleParticles() {
  for (const p of titleParticles) {
    ctx.globalAlpha = p.alpha;
    ctx.strokeStyle = p.color;
    ctx.lineWidth = 1;
    setGlow(ctx, p.color, 8);
    drawPolygon(p.x, p.y, p.radius, p.sides, p.angle, false);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
  clearGlow(ctx);
}

initTitleParticles();

// --- HUD ---
let scoreBumpTimer = 0;

function updateHUD(dt) {
  // Animate score display
  if (displayScore < score) {
    const diff = score - displayScore;
    displayScore += Math.ceil(diff * Math.min(1, dt * 10));
    if (displayScore > score) displayScore = score;
    scoreBumpTimer = 0.1;
  }
  scoreBumpTimer = Math.max(0, scoreBumpTimer - dt);

  hudScore.textContent = displayScore.toLocaleString();
  hudScore.classList.toggle('bump', scoreBumpTimer > 0);
  hudHi.textContent = `HI: ${Math.max(hiScore, score).toLocaleString()}`;
  hudWave.textContent = `WAVE ${wave}`;
  bombFill.style.height = (bombCharge * 100) + '%';
  bombBtn.classList.toggle('charged', bombCharge >= 1);

  // Combo display
  if (comboCount >= 2 && comboTimer > 0) {
    hudCombo.textContent = `x${comboCount} COMBO`;
    hudCombo.classList.add('visible');
  } else {
    hudCombo.classList.remove('visible');
  }
}

// --- Main Loop ---
let lastTime = 0;

function gameLoop(timestamp) {
  requestAnimationFrame(gameLoop);

  const dt = Math.min((timestamp - lastTime) / 1000, 1/20);
  lastTime = timestamp;

  if (state === STATE.PLAYING && fireHeld && ship.fireTimer <= 0 && !ship.dead) {
    fireProjectile();
    ship.fireTimer = ship.fireRate;
  }

  updateShake(dt);
  updateGrid(dt);
  updateParticles(dt);
  updateBombRings(dt);
  updateFloatingTexts(dt);

  if (state === STATE.TITLE) {
    updateTitleParticles(dt);
  }

  if (state === STATE.PLAYING) {
    gameTime += dt;

    // Combo timer
    if (comboTimer > 0) {
      comboTimer -= dt;
      if (comboTimer <= 0) comboCount = 0;
    }

    if (bombCharging && bombCharge < 1) {
      bombCharge = Math.min(1, bombCharge + dt / BOMB_CHARGE_TIME);
    }

    updateShip(dt);
    updateProjectiles(dt);
    updateEnemies(dt);
    updateWaves(dt);
    checkCollisions();
    updateHUD(dt);
  }

  // Draw
  drawGrid();
  ctx.clearRect(0, 0, W, H);
  ctx.save();
  ctx.translate(shakeX, shakeY);

  if (state === STATE.TITLE) drawTitleParticles();

  if (state === STATE.PLAYING || state === STATE.GAME_OVER) {
    drawBombRings();
    drawProjectiles();
    drawEnemies();
    drawShip();
    drawParticles();
    drawFloatingTexts();
  }

  ctx.restore();

  // Flash overlay
  if (flashAlpha > 0.005) {
    ctx.globalAlpha = flashAlpha;
    ctx.fillStyle = flashColor;
    ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
  }

  drawPostProcessing();
}

function drawPostProcessing() {
  // Vignette
  const grad = ctx.createRadialGradient(CX, CY, Math.min(W, H) * 0.25, CX, CY, Math.max(W, H) * 0.8);
  grad.addColorStop(0, 'transparent');
  grad.addColorStop(0.7, 'rgba(0,0,15,0.2)');
  grad.addColorStop(1, 'rgba(0,0,15,0.55)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Subtle scanlines
  ctx.fillStyle = 'rgba(0,0,0,0.03)';
  for (let y = 0; y < H; y += 3) {
    ctx.fillRect(0, y, W, 1);
  }

  // CRT curvature edge darkening (corners)
  const cornerGrad = ctx.createRadialGradient(CX, CY, Math.min(W, H) * 0.5, CX, CY, Math.hypot(CX, CY));
  cornerGrad.addColorStop(0, 'transparent');
  cornerGrad.addColorStop(1, 'rgba(0,0,0,0.25)');
  ctx.fillStyle = cornerGrad;
  ctx.fillRect(0, 0, W, H);
}

// Start
showTitle();
requestAnimationFrame(gameLoop);

})();
</script>
</body>
</html>
