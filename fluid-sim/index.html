<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Fluid Sim — Interactive Ink in Water</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none}
canvas{display:block;width:100%;height:100%}
#ui{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:12px;z-index:10}
#ui button{background:rgba(255,255,255,.15);border:none;color:#fff;font:600 14px/1 system-ui;padding:10px 18px;border-radius:24px;backdrop-filter:blur(8px);cursor:pointer;-webkit-tap-highlight-color:transparent}
#ui button:active{background:rgba(255,255,255,.3)}
#title{position:fixed;top:16px;left:50%;transform:translateX(-50%);color:rgba(255,255,255,.5);font:300 13px/1 system-ui;letter-spacing:.5px;pointer-events:none;transition:opacity 1s}
</style>
</head>
<body>
<div id="title">touch to add ink</div>
<div id="ui">
  <button onclick="clearFluid()">Clear</button>
  <button onclick="cycleMode()">Mode</button>
</div>
<canvas id="c"></canvas>
<script>
// WebGL Fluid Simulation — Navier-Stokes based
// Inspired by Jos Stam's "Stable Fluids" and Pavel Dobryakov's implementation

const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
const ext = gl.getExtension('EXT_color_buffer_float') || gl.getExtension('EXT_color_buffer_half_float');
gl.getExtension('OES_texture_float');
gl.getExtension('OES_texture_float_linear');
gl.getExtension('OES_texture_half_float');
gl.getExtension('OES_texture_half_float_linear');

let SIM_W = 256, SIM_H = 256;
let DYE_W = 1024, DYE_H = 1024;
let mode = 0;
const modes = ['rainbow', 'neon', 'pastel'];

function resize() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  const aspect = canvas.width / canvas.height;
  if (aspect > 1) {
    SIM_H = 256; SIM_W = Math.round(256 * aspect);
    DYE_H = 1024; DYE_W = Math.round(1024 * aspect);
  } else {
    SIM_W = 256; SIM_H = Math.round(256 / aspect);
    DYE_W = 1024; DYE_H = Math.round(1024 / aspect);
  }
}
resize();

// Shader compilation
function compileShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
  return s;
}

function createProgram(vs, fs) {
  const p = gl.createProgram();
  gl.attachShader(p, compileShader(gl.VERTEX_SHADER, vs));
  gl.attachShader(p, compileShader(gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
  const uniforms = {};
  const n = gl.getProgramParameter(p, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveUniform(p, i);
    uniforms[info.name] = gl.getUniformLocation(p, info.name);
  }
  return { program: p, uniforms };
}

const baseVS = `attribute vec2 aPosition;varying vec2 vUv;void main(){vUv=aPosition*.5+.5;gl_Position=vec4(aPosition,0,1);}`;

// Fullscreen quad
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);

function blit(target, w, h) {
  if (target) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
    gl.viewport(0, 0, w || target.width, h || target.height);
  } else {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

// Framebuffer helpers
const texType = gl.FLOAT;
const internalFormat = gl.getParameter(gl.VERSION).includes('WebGL 2') ? 0x8814 : gl.RGBA; // RGBA32F or RGBA
const format = gl.RGBA;

function createFBO(w, h, filter) {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter || gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter || gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, texType, null);
  const fbo = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
  return { texture: tex, fbo, width: w, height: h };
}

function createDoubleFBO(w, h, filter) {
  let a = createFBO(w, h, filter);
  let b = createFBO(w, h, filter);
  return {
    width: w, height: h,
    get read() { return a; },
    get write() { return b; },
    swap() { [a, b] = [b, a]; }
  };
}

// Programs
const splatProg = createProgram(baseVS, `
precision highp float;
varying vec2 vUv;
uniform sampler2D uTarget;
uniform float aspectRatio;
uniform vec3 color;
uniform vec2 point;
uniform float radius;
void main(){
  vec2 p=vUv-point;
  p.x*=aspectRatio;
  vec3 splat=exp(-dot(p,p)/radius)*color;
  vec3 base=texture2D(uTarget,vUv).xyz;
  gl_FragColor=vec4(base+splat,1.0);
}`);

const advectionProg = createProgram(baseVS, `
precision highp float;
varying vec2 vUv;
uniform sampler2D uVelocity;
uniform sampler2D uSource;
uniform vec2 texelSize;
uniform float dt;
uniform float dissipation;
void main(){
  vec2 coord=vUv-dt*texture2D(uVelocity,vUv).xy*texelSize;
  vec3 result=dissipation*texture2D(uSource,coord).xyz;
  gl_FragColor=vec4(result,1.0);
}`);

const divergenceProg = createProgram(baseVS, `
precision highp float;
varying vec2 vUv;
uniform sampler2D uVelocity;
uniform vec2 texelSize;
void main(){
  float L=texture2D(uVelocity,vUv-vec2(texelSize.x,0)).x;
  float R=texture2D(uVelocity,vUv+vec2(texelSize.x,0)).x;
  float T=texture2D(uVelocity,vUv+vec2(0,texelSize.y)).y;
  float B=texture2D(uVelocity,vUv-vec2(0,texelSize.y)).y;
  float div=.5*(R-L+T-B);
  gl_FragColor=vec4(div,0,0,1);
}`);

const pressureProg = createProgram(baseVS, `
precision highp float;
varying vec2 vUv;
uniform sampler2D uPressure;
uniform sampler2D uDivergence;
uniform vec2 texelSize;
void main(){
  float L=texture2D(uPressure,vUv-vec2(texelSize.x,0)).x;
  float R=texture2D(uPressure,vUv+vec2(texelSize.x,0)).x;
  float T=texture2D(uPressure,vUv+vec2(0,texelSize.y)).x;
  float B=texture2D(uPressure,vUv-vec2(0,texelSize.y)).x;
  float div=texture2D(uDivergence,vUv).x;
  float p=(L+R+T+B-div)*.25;
  gl_FragColor=vec4(p,0,0,1);
}`);

const gradientSubProg = createProgram(baseVS, `
precision highp float;
varying vec2 vUv;
uniform sampler2D uPressure;
uniform sampler2D uVelocity;
uniform vec2 texelSize;
void main(){
  float L=texture2D(uPressure,vUv-vec2(texelSize.x,0)).x;
  float R=texture2D(uPressure,vUv+vec2(texelSize.x,0)).x;
  float T=texture2D(uPressure,vUv+vec2(0,texelSize.y)).x;
  float B=texture2D(uPressure,vUv-vec2(0,texelSize.y)).x;
  vec2 vel=texture2D(uVelocity,vUv).xy;
  vel-=.5*vec2(R-L,T-B);
  gl_FragColor=vec4(vel,0,1);
}`);

const curlProg = createProgram(baseVS, `
precision highp float;
varying vec2 vUv;
uniform sampler2D uVelocity;
uniform vec2 texelSize;
void main(){
  float L=texture2D(uVelocity,vUv-vec2(texelSize.x,0)).y;
  float R=texture2D(uVelocity,vUv+vec2(texelSize.x,0)).y;
  float T=texture2D(uVelocity,vUv+vec2(0,texelSize.y)).x;
  float B=texture2D(uVelocity,vUv-vec2(0,texelSize.y)).x;
  float curl=R-L-(T-B);
  gl_FragColor=vec4(.5*curl,0,0,1);
}`);

const vorticityProg = createProgram(baseVS, `
precision highp float;
varying vec2 vUv;
uniform sampler2D uVelocity;
uniform sampler2D uCurl;
uniform vec2 texelSize;
uniform float curl;
uniform float dt;
void main(){
  float L=texture2D(uCurl,vUv-vec2(texelSize.x,0)).x;
  float R=texture2D(uCurl,vUv+vec2(texelSize.x,0)).x;
  float T=texture2D(uCurl,vUv+vec2(0,texelSize.y)).x;
  float B=texture2D(uCurl,vUv-vec2(0,texelSize.y)).x;
  float C=texture2D(uCurl,vUv).x;
  vec2 force=.5*vec2(abs(T)-abs(B),abs(R)-abs(L));
  force/=length(force)+1e-5;
  force*=curl*C;
  force.y*=-1.0;
  vec2 vel=texture2D(uVelocity,vUv).xy+force*dt;
  gl_FragColor=vec4(vel,0,1);
}`);

const displayProg = createProgram(baseVS, `
precision highp float;
varying vec2 vUv;
uniform sampler2D uTexture;
void main(){
  vec3 c=texture2D(uTexture,vUv).rgb;
  // Slight tone mapping for richness
  c=pow(c,vec3(.85));
  gl_FragColor=vec4(c,1);
}`);

const clearProg = createProgram(baseVS, `
precision highp float;
varying vec2 vUv;
uniform sampler2D uTexture;
uniform float value;
void main(){
  gl_FragColor=value*texture2D(uTexture,vUv);
}`);

// Initialize FBOs
let velocity = createDoubleFBO(SIM_W, SIM_H);
let pressure = createDoubleFBO(SIM_W, SIM_H);
let dye = createDoubleFBO(DYE_W, DYE_H);
let divergenceFBO = createFBO(SIM_W, SIM_H, gl.NEAREST);
let curlFBO = createFBO(SIM_W, SIM_H, gl.NEAREST);

// Attribute
const posLoc = gl.getAttribLocation(splatProg.program, 'aPosition');
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

// Input handling
const pointers = [];
let hue = Math.random() * 360;

function getPointer(id) {
  let p = pointers.find(p => p.id === id);
  if (!p) { p = { id, x: 0, y: 0, dx: 0, dy: 0, down: false, color: [0,0,0] }; pointers.push(p); }
  return p;
}

function updatePointer(p, x, y) {
  const px = x / window.innerWidth, py = 1 - y / window.innerHeight;
  p.dx = (px - p.x) * 10; p.dy = (py - p.y) * 10;
  p.x = px; p.y = py;
}

function HSVtoRGB(h, s, v) {
  const i = Math.floor(h * 6), f = h * 6 - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s);
  let r, g, b;
  switch (i % 6) {
    case 0: r=v;g=t;b=p;break; case 1: r=q;g=v;b=p;break; case 2: r=p;g=v;b=t;break;
    case 3: r=p;g=q;b=v;break; case 4: r=t;g=p;b=v;break; case 5: r=v;g=p;b=q;break;
  }
  return [r, g, b];
}

function getColor() {
  hue += 1.3;
  if (mode === 0) return HSVtoRGB((hue % 360) / 360, .8, .9); // rainbow
  if (mode === 1) { // neon
    const c = HSVtoRGB((hue % 360) / 360, 1, 1);
    return [c[0]*1.5, c[1]*1.5, c[2]*1.5];
  }
  return HSVtoRGB((hue % 360) / 360, .4, 1); // pastel
}

canvas.addEventListener('pointerdown', e => {
  e.preventDefault();
  const p = getPointer(e.pointerId);
  updatePointer(p, e.clientX, e.clientY);
  p.down = true;
  p.color = getColor();
  document.getElementById('title').style.opacity = '0';
});
canvas.addEventListener('pointermove', e => {
  e.preventDefault();
  const p = getPointer(e.pointerId);
  if (!p.down) return;
  updatePointer(p, e.clientX, e.clientY);
});
canvas.addEventListener('pointerup', e => { getPointer(e.pointerId).down = false; });
canvas.addEventListener('pointercancel', e => { getPointer(e.pointerId).down = false; });

// Apply splat
function splat(x, y, dx, dy, color) {
  // Velocity splat
  gl.useProgram(splatProg.program);
  gl.uniform1i(splatProg.uniforms.uTarget, 0);
  gl.uniform1f(splatProg.uniforms.aspectRatio, canvas.width / canvas.height);
  gl.uniform2f(splatProg.uniforms.point, x, y);
  gl.uniform3f(splatProg.uniforms.color, dx, dy, 0);
  gl.uniform1f(splatProg.uniforms.radius, .0001);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
  blit(velocity.write);
  velocity.swap();

  // Dye splat
  gl.uniform3f(splatProg.uniforms.color, color[0] * .3, color[1] * .3, color[2] * .3);
  gl.uniform1f(splatProg.uniforms.radius, .0004);
  gl.bindTexture(gl.TEXTURE_2D, dye.read.texture);
  blit(dye.write);
  dye.swap();
}

function step(dt) {
  const simTexel = [1 / SIM_W, 1 / SIM_H];
  const dyeTexel = [1 / DYE_W, 1 / DYE_H];

  // Curl
  gl.useProgram(curlProg.program);
  gl.uniform2f(curlProg.uniforms.texelSize, simTexel[0], simTexel[1]);
  gl.uniform1i(curlProg.uniforms.uVelocity, 0);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
  blit(curlFBO);

  // Vorticity confinement
  gl.useProgram(vorticityProg.program);
  gl.uniform2f(vorticityProg.uniforms.texelSize, simTexel[0], simTexel[1]);
  gl.uniform1i(vorticityProg.uniforms.uVelocity, 0);
  gl.uniform1i(vorticityProg.uniforms.uCurl, 1);
  gl.uniform1f(vorticityProg.uniforms.curl, 30);
  gl.uniform1f(vorticityProg.uniforms.dt, dt);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, curlFBO.texture);
  blit(velocity.write);
  velocity.swap();

  // Divergence
  gl.useProgram(divergenceProg.program);
  gl.uniform2f(divergenceProg.uniforms.texelSize, simTexel[0], simTexel[1]);
  gl.uniform1i(divergenceProg.uniforms.uVelocity, 0);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
  blit(divergenceFBO);

  // Clear pressure
  gl.useProgram(clearProg.program);
  gl.uniform1i(clearProg.uniforms.uTexture, 0);
  gl.uniform1f(clearProg.uniforms.value, .8);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
  blit(pressure.write);
  pressure.swap();

  // Pressure solve (Jacobi iterations)
  gl.useProgram(pressureProg.program);
  gl.uniform2f(pressureProg.uniforms.texelSize, simTexel[0], simTexel[1]);
  gl.uniform1i(pressureProg.uniforms.uDivergence, 1);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, divergenceFBO.texture);
  for (let i = 0; i < 32; i++) {
    gl.uniform1i(pressureProg.uniforms.uPressure, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
    blit(pressure.write);
    pressure.swap();
  }

  // Gradient subtract
  gl.useProgram(gradientSubProg.program);
  gl.uniform2f(gradientSubProg.uniforms.texelSize, simTexel[0], simTexel[1]);
  gl.uniform1i(gradientSubProg.uniforms.uPressure, 0);
  gl.uniform1i(gradientSubProg.uniforms.uVelocity, 1);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
  blit(velocity.write);
  velocity.swap();

  // Advect velocity
  gl.useProgram(advectionProg.program);
  gl.uniform2f(advectionProg.uniforms.texelSize, simTexel[0], simTexel[1]);
  gl.uniform1i(advectionProg.uniforms.uVelocity, 0);
  gl.uniform1i(advectionProg.uniforms.uSource, 0);
  gl.uniform1f(advectionProg.uniforms.dt, dt);
  gl.uniform1f(advectionProg.uniforms.dissipation, .99);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
  blit(velocity.write);
  velocity.swap();

  // Advect dye
  gl.uniform2f(advectionProg.uniforms.texelSize, dyeTexel[0], dyeTexel[1]);
  gl.uniform1i(advectionProg.uniforms.uVelocity, 0);
  gl.uniform1i(advectionProg.uniforms.uSource, 1);
  gl.uniform1f(advectionProg.uniforms.dissipation, .985);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, velocity.read.texture);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, dye.read.texture);
  blit(dye.write);
  dye.swap();
}

function render() {
  gl.useProgram(displayProg.program);
  gl.uniform1i(displayProg.uniforms.uTexture, 0);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, dye.read.texture);
  blit(null);
}

let lastTime = performance.now();

function loop() {
  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 1/30);
  lastTime = now;

  // Apply pointer splats
  for (const p of pointers) {
    if (p.down && (Math.abs(p.dx) > .0001 || Math.abs(p.dy) > .0001)) {
      p.color = getColor();
      splat(p.x, p.y, p.dx * 50, p.dy * 50, p.color);
    }
  }

  step(dt);
  render();
  requestAnimationFrame(loop);
}

// Random initial splashes for visual appeal
setTimeout(() => {
  for (let i = 0; i < 5; i++) {
    const c = getColor();
    const angle = Math.random() * Math.PI * 2;
    splat(Math.random(), Math.random(), Math.cos(angle) * 200, Math.sin(angle) * 200, c);
  }
}, 100);

window.addEventListener('resize', () => {
  resize();
  // Recreate FBOs on resize
  velocity = createDoubleFBO(SIM_W, SIM_H);
  pressure = createDoubleFBO(SIM_W, SIM_H);
  dye = createDoubleFBO(DYE_W, DYE_H);
  divergenceFBO = createFBO(SIM_W, SIM_H, gl.NEAREST);
  curlFBO = createFBO(SIM_W, SIM_H, gl.NEAREST);
});

function clearFluid() {
  velocity = createDoubleFBO(SIM_W, SIM_H);
  pressure = createDoubleFBO(SIM_W, SIM_H);
  dye = createDoubleFBO(DYE_W, DYE_H);
}

function cycleMode() {
  mode = (mode + 1) % modes.length;
}

loop();
</script>
</body>
</html>
