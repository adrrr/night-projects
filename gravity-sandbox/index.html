<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Gravity Sandbox</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0a1a; touch-action: none; }
canvas { display: block; }
#ui {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  display: flex; gap: 10px; z-index: 10;
}
#ui button {
  background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
  color: #fff; font-size: 14px; padding: 10px 16px; border-radius: 20px;
  backdrop-filter: blur(10px); cursor: pointer; transition: all 0.2s;
  -webkit-tap-highlight-color: transparent;
}
#ui button.active { background: rgba(100,140,255,0.3); border-color: rgba(100,140,255,0.6); }
#ui button:active { transform: scale(0.95); }
#info {
  position: fixed; top: 16px; left: 16px; color: rgba(255,255,255,0.5);
  font: 13px -apple-system, sans-serif; z-index: 10; pointer-events: none;
}
#hint {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
  color: rgba(255,255,255,0.25); font: 18px -apple-system, sans-serif;
  text-align: center; z-index: 10; pointer-events: none;
  transition: opacity 0.5s;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="info"><span id="count">0</span> corps</div>
<div id="hint">Touche l'écran pour créer des étoiles ✨<br><small>Maintiens pour une masse plus grande</small></div>
<div id="ui">
  <button id="btnTrails" class="active">Trails</button>
  <button id="btnClear">Clear</button>
  <button id="btnPreset">Big Bang</button>
</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const hint = document.getElementById('hint');
const countEl = document.getElementById('count');

let W, H, dpr;
function resize() {
  dpr = window.devicePixelRatio || 1;
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resize();
window.addEventListener('resize', resize);

const G = 800;
const bodies = [];
let trails = true;
let pressing = null; // {x, y, start}

class Body {
  constructor(x, y, mass, vx = 0, vy = 0) {
    this.x = x; this.y = y;
    this.mass = mass;
    this.vx = vx; this.vy = vy;
    this.radius = Math.pow(mass, 0.4) * 2;
    this.hue = Math.random() * 360;
    this.trail = [];
    this.alive = true;
  }
}

function addBody(x, y, mass, vx = 0, vy = 0) {
  bodies.push(new Body(x, y, mass, vx, vy));
  countEl.textContent = bodies.length;
  if (hint.style.opacity !== '0') hint.style.opacity = '0';
}

// Touch / mouse
function getPos(e) {
  const t = e.touches ? e.touches[0] : e;
  return { x: t.clientX, y: t.clientY };
}

canvas.addEventListener('pointerdown', e => {
  e.preventDefault();
  pressing = { ...getPos(e), start: performance.now() };
});

canvas.addEventListener('pointerup', e => {
  if (!pressing) return;
  const pos = e.changedTouches ? { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY } : { x: e.clientX, y: e.clientY };
  const held = (performance.now() - pressing.start) / 1000;
  const mass = Math.min(5 + held * 40, 200);
  const dx = (pos.x - pressing.x) * 0.1;
  const dy = (pos.y - pressing.y) * 0.1;
  addBody(pressing.x, pressing.y, mass, -dx, -dy);
  pressing = null;
});

canvas.addEventListener('pointercancel', () => { pressing = null; });

// Buttons
document.getElementById('btnTrails').addEventListener('click', function() {
  trails = !trails; this.classList.toggle('active', trails);
});
document.getElementById('btnClear').addEventListener('click', () => {
  bodies.length = 0; countEl.textContent = 0;
  ctx.clearRect(0, 0, W, H); hint.style.opacity = '1';
});
document.getElementById('btnPreset').addEventListener('click', () => {
  bodies.length = 0;
  const cx = W / 2, cy = H / 2;
  addBody(cx, cy, 150);
  for (let i = 0; i < 40; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 80 + Math.random() * 180;
    const speed = Math.sqrt(G * 150 / dist) * (0.7 + Math.random() * 0.6);
    addBody(
      cx + Math.cos(angle) * dist,
      cy + Math.sin(angle) * dist,
      1 + Math.random() * 4,
      -Math.sin(angle) * speed,
      Math.cos(angle) * speed
    );
  }
});

// Physics
function step(dt) {
  const n = bodies.length;
  // Gravity
  for (let i = 0; i < n; i++) {
    if (!bodies[i].alive) continue;
    for (let j = i + 1; j < n; j++) {
      if (!bodies[j].alive) continue;
      const a = bodies[i], b = bodies[j];
      const dx = b.x - a.x, dy = b.y - a.y;
      const dist2 = dx * dx + dy * dy + 100; // softening
      const dist = Math.sqrt(dist2);
      const F = G * a.mass * b.mass / dist2;
      const fx = F * dx / dist, fy = F * dy / dist;
      a.vx += fx / a.mass * dt; a.vy += fy / a.mass * dt;
      b.vx -= fx / b.mass * dt; b.vy -= fy / b.mass * dt;
      // Merge
      if (dist < a.radius + b.radius) {
        if (a.mass >= b.mass) {
          a.vx = (a.vx * a.mass + b.vx * b.mass) / (a.mass + b.mass);
          a.vy = (a.vy * a.mass + b.vy * b.mass) / (a.mass + b.mass);
          a.mass += b.mass;
          a.radius = Math.pow(a.mass, 0.4) * 2;
          b.alive = false;
        } else {
          b.vx = (a.vx * a.mass + b.vx * b.mass) / (a.mass + b.mass);
          b.vy = (a.vy * a.mass + b.vy * b.mass) / (a.mass + b.mass);
          b.mass += a.mass;
          b.radius = Math.pow(b.mass, 0.4) * 2;
          a.alive = false;
        }
      }
    }
  }
  // Move
  for (let i = n - 1; i >= 0; i--) {
    const b = bodies[i];
    if (!b.alive) { bodies.splice(i, 1); continue; }
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.trail.push({ x: b.x, y: b.y });
    if (b.trail.length > 80) b.trail.shift();
  }
  countEl.textContent = bodies.length;
}

// Render
let lastTime = 0;
function draw(time) {
  const dt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;

  if (trails) {
    ctx.fillStyle = 'rgba(10,10,26,0.15)';
    ctx.fillRect(0, 0, W, H);
  } else {
    ctx.clearRect(0, 0, W, H);
  }

  step(dt);

  // Draw trails
  if (trails) {
    for (const b of bodies) {
      if (b.trail.length < 2) continue;
      ctx.beginPath();
      ctx.moveTo(b.trail[0].x, b.trail[0].y);
      for (let i = 1; i < b.trail.length; i++) {
        ctx.lineTo(b.trail[i].x, b.trail[i].y);
      }
      ctx.strokeStyle = `hsla(${b.hue}, 80%, 60%, 0.3)`;
      ctx.lineWidth = Math.max(1, b.radius * 0.4);
      ctx.stroke();
    }
  }

  // Draw bodies
  for (const b of bodies) {
    const r = b.radius;
    const grad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, r * 2);
    grad.addColorStop(0, `hsla(${b.hue}, 80%, 80%, 1)`);
    grad.addColorStop(0.4, `hsla(${b.hue}, 80%, 60%, 0.8)`);
    grad.addColorStop(1, `hsla(${b.hue}, 80%, 40%, 0)`);
    ctx.beginPath();
    ctx.arc(b.x, b.y, r * 2, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
    // Core
    ctx.beginPath();
    ctx.arc(b.x, b.y, r * 0.6, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${b.hue}, 60%, 95%, 0.9)`;
    ctx.fill();
  }

  // Draw press indicator
  if (pressing) {
    const held = (performance.now() - pressing.start) / 1000;
    const r = Math.pow(Math.min(5 + held * 40, 200), 0.4) * 2;
    ctx.beginPath();
    ctx.arc(pressing.x, pressing.y, r * 2, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);
</script>
</body>
</html>
