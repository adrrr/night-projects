<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Kaleidoscope</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --ui-bg: rgba(0, 0, 0, 0.55);
    --ui-bg-hover: rgba(255, 255, 255, 0.12);
    --ui-border: rgba(255, 255, 255, 0.15);
    --ui-text: #e8e8e8;
    --ui-accent: #7eb8ff;
    --ui-radius: 14px;
    --ui-gap: 10px;
    --safe-bottom: env(safe-area-inset-bottom, 0px);
  }

  html, body {
    height: 100%; width: 100%;
    overflow: hidden;
    background: #000;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    touch-action: none;
    -webkit-user-select: none; user-select: none;
    color: var(--ui-text);
  }

  canvas#kaleidoscope {
    position: fixed; inset: 0;
    width: 100%; height: 100%;
    display: block;
    cursor: crosshair;
  }

  /* ── Top bar ── */
  .top-bar {
    position: fixed; top: 0; left: 0; right: 0;
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 16px;
    z-index: 10;
    pointer-events: none;
  }
  .top-bar > * { pointer-events: auto; }

  .title {
    font-size: 15px; font-weight: 600; letter-spacing: 0.5px;
    text-shadow: 0 1px 6px rgba(0,0,0,0.7);
    opacity: 0.7;
    transition: opacity 0.3s;
  }

  /* ── Buttons ── */
  .btn {
    display: inline-flex; align-items: center; justify-content: center;
    min-width: 44px; min-height: 44px;
    padding: 8px 14px;
    background: var(--ui-bg);
    border: 1px solid var(--ui-border);
    border-radius: var(--ui-radius);
    color: var(--ui-text);
    font-size: 14px; font-weight: 500;
    cursor: pointer;
    backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
    transition: background 0.2s, transform 0.15s, border-color 0.2s;
    gap: 6px;
    white-space: nowrap;
  }
  .btn:active { transform: scale(0.94); background: var(--ui-bg-hover); }
  .btn svg { width: 18px; height: 18px; flex-shrink: 0; }
  .btn.active { border-color: var(--ui-accent); background: rgba(126,184,255,0.15); }

  .btn-icon {
    padding: 8px; min-width: 44px; min-height: 44px;
    border-radius: 50%;
  }

  .btn-group {
    display: flex; gap: 2px;
    background: var(--ui-bg);
    border: 1px solid var(--ui-border);
    border-radius: var(--ui-radius);
    backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
    overflow: hidden;
  }
  .btn-group .btn {
    border: none; border-radius: 0;
    background: transparent;
    backdrop-filter: none; -webkit-backdrop-filter: none;
    min-width: 48px;
    font-size: 13px; font-weight: 600;
  }
  .btn-group .btn.active { background: rgba(126,184,255,0.2); color: var(--ui-accent); }
  .btn-group .btn + .btn { border-left: 1px solid var(--ui-border); }

  /* ── Bottom panel ── */
  .bottom-panel {
    position: fixed; bottom: 0; left: 0; right: 0;
    display: flex; flex-direction: column; gap: var(--ui-gap);
    padding: 12px 16px calc(12px + var(--safe-bottom));
    z-index: 10;
    pointer-events: none;
  }
  .bottom-panel > * { pointer-events: auto; }

  .controls-row {
    display: flex; align-items: center; gap: var(--ui-gap);
    justify-content: center;
    flex-wrap: wrap;
  }

  /* ── Slider ── */
  .slider-group {
    display: flex; align-items: center; gap: 8px;
    background: var(--ui-bg);
    border: 1px solid var(--ui-border);
    border-radius: var(--ui-radius);
    padding: 6px 14px;
    backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
    flex: 1; min-width: 160px; max-width: 280px;
  }
  .slider-label {
    font-size: 11px; font-weight: 600; text-transform: uppercase;
    letter-spacing: 0.5px; opacity: 0.6;
    min-width: 36px;
  }
  input[type="range"] {
    -webkit-appearance: none; appearance: none;
    flex: 1; height: 32px;
    background: transparent; cursor: pointer;
  }
  input[type="range"]::-webkit-slider-runnable-track {
    height: 4px; border-radius: 2px;
    background: linear-gradient(90deg, rgba(255,255,255,0.15), var(--ui-accent));
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 22px; height: 22px; border-radius: 50%;
    background: #fff;
    border: 2px solid var(--ui-accent);
    margin-top: -9px;
    box-shadow: 0 1px 6px rgba(0,0,0,0.4);
  }
  input[type="range"]::-moz-range-track {
    height: 4px; border-radius: 2px; border: none;
    background: linear-gradient(90deg, rgba(255,255,255,0.15), var(--ui-accent));
  }
  input[type="range"]::-moz-range-thumb {
    width: 22px; height: 22px; border-radius: 50%;
    background: #fff;
    border: 2px solid var(--ui-accent);
    box-shadow: 0 1px 6px rgba(0,0,0,0.4);
  }

  /* ── Color mode pill ── */
  .color-modes {
    display: flex; gap: 6px;
  }
  .color-dot {
    width: 32px; height: 32px;
    border-radius: 50%;
    border: 2px solid transparent;
    cursor: pointer;
    transition: border-color 0.2s, transform 0.15s;
    min-width: 44px; min-height: 44px;
    display: flex; align-items: center; justify-content: center;
  }
  .color-dot:active { transform: scale(0.9); }
  .color-dot.active { border-color: #fff; }
  .color-dot-inner {
    width: 24px; height: 24px; border-radius: 50%;
  }

  /* ── Toast ── */
  .toast {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0.9);
    background: var(--ui-bg);
    border: 1px solid var(--ui-border);
    border-radius: 20px;
    padding: 16px 28px;
    font-size: 15px; font-weight: 500;
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    opacity: 0;
    transition: opacity 0.3s, transform 0.3s;
    pointer-events: none;
    z-index: 100;
  }
  .toast.show {
    opacity: 1; transform: translate(-50%, -50%) scale(1);
  }

  /* ── Intro overlay ── */
  .intro {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    background: rgba(0,0,0,0.75);
    backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    z-index: 50;
    transition: opacity 0.6s;
    padding: 24px;
    text-align: center;
  }
  .intro.hidden { opacity: 0; pointer-events: none; }
  .intro h1 {
    font-size: clamp(28px, 6vw, 48px);
    font-weight: 700;
    background: linear-gradient(135deg, #7eb8ff, #c084fc, #fb7185, #fbbf24);
    -webkit-background-clip: text; background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 12px;
  }
  .intro p {
    font-size: 16px; opacity: 0.6;
    max-width: 320px; line-height: 1.5;
    margin-bottom: 32px;
  }
  .intro .btn { font-size: 16px; padding: 14px 36px; border-radius: 24px; }

  /* ── Brush size indicator ── */
  .brush-indicator {
    position: fixed;
    border-radius: 50%;
    border: 1.5px solid rgba(255,255,255,0.4);
    pointer-events: none;
    z-index: 5;
    opacity: 0;
    transition: opacity 0.2s;
  }

  /* ── Responsive ── */
  @media (max-width: 480px) {
    .slider-group { max-width: 100%; }
    .title { font-size: 13px; }
  }
</style>
</head>
<body>

<canvas id="kaleidoscope"></canvas>

<div class="brush-indicator" id="brushIndicator"></div>

<!-- Top bar -->
<div class="top-bar">
  <span class="title">Kaleidoscope</span>
  <div style="display:flex;gap:8px;">
    <button class="btn btn-icon" id="btnUndo" title="Undo" aria-label="Undo">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 10h13a4 4 0 0 1 0 8H7"/><path d="m3 10 4-4"/><path d="m3 10 4 4"/></svg>
    </button>
    <button class="btn btn-icon" id="btnClear" title="Clear" aria-label="Clear canvas">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4h8v2"/><path d="M5 6v14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V6"/></svg>
    </button>
    <button class="btn btn-icon" id="btnSave" title="Save screenshot" aria-label="Save screenshot">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
    </button>
  </div>
</div>

<!-- Bottom panel -->
<div class="bottom-panel">
  <!-- Symmetry toggle -->
  <div class="controls-row">
    <div class="btn-group" id="symmetryGroup">
      <button class="btn" data-sym="6">6</button>
      <button class="btn active" data-sym="8">8</button>
      <button class="btn" data-sym="12">12</button>
      <button class="btn" data-sym="16">16</button>
    </div>
    <div class="btn-group" id="brushGroup">
      <button class="btn active" data-brush="round" title="Round brush">
        <svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="6"/></svg>
      </button>
      <button class="btn" data-brush="glow" title="Glow brush">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="12" cy="12" r="5"/><line x1="12" y1="2" x2="12" y2="5"/><line x1="12" y1="19" x2="12" y2="22"/><line x1="2" y1="12" x2="5" y2="12"/><line x1="19" y1="12" x2="22" y2="12"/></svg>
      </button>
      <button class="btn" data-brush="ribbon" title="Ribbon brush">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M4 18c2-4 6-12 16-14"/></svg>
      </button>
    </div>
  </div>

  <!-- Sliders & colors -->
  <div class="controls-row">
    <div class="slider-group">
      <span class="slider-label">Trail</span>
      <input type="range" id="trailSlider" min="0" max="100" value="92">
    </div>
    <div class="slider-group">
      <span class="slider-label">Size</span>
      <input type="range" id="sizeSlider" min="2" max="40" value="8">
    </div>
  </div>

  <div class="controls-row">
    <div class="color-modes" id="colorModes">
      <div class="color-dot active" data-color="rainbow" title="Rainbow">
        <div class="color-dot-inner" style="background:conic-gradient(#f00,#ff0,#0f0,#0ff,#00f,#f0f,#f00);"></div>
      </div>
      <div class="color-dot" data-color="ocean" title="Ocean">
        <div class="color-dot-inner" style="background:linear-gradient(135deg,#064e7b,#0ea5e9,#67e8f9);"></div>
      </div>
      <div class="color-dot" data-color="sunset" title="Sunset">
        <div class="color-dot-inner" style="background:linear-gradient(135deg,#7c2d12,#ea580c,#fbbf24);"></div>
      </div>
      <div class="color-dot" data-color="aurora" title="Aurora">
        <div class="color-dot-inner" style="background:linear-gradient(135deg,#4338ca,#22d3ee,#a3e635);"></div>
      </div>
      <div class="color-dot" data-color="white" title="White">
        <div class="color-dot-inner" style="background:#e8e8e8;"></div>
      </div>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<!-- Intro -->
<div class="intro" id="intro">
  <h1>Kaleidoscope</h1>
  <p>Draw with your finger or mouse to create mesmerizing symmetric patterns.</p>
  <button class="btn" id="btnStart">Begin Drawing</button>
</div>

<script>
(() => {
  'use strict';

  // ── Canvas setup ──
  const canvas = document.getElementById('kaleidoscope');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const brushIndicator = document.getElementById('brushIndicator');

  let W, H, cx, cy;
  let dpr = Math.min(window.devicePixelRatio || 1, 2);

  function resize() {
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    cx = W / 2;
    cy = H / 2;
  }
  resize();
  window.addEventListener('resize', resize);

  // ── State ──
  let symmetry = 8;
  let trailPersistence = 0.92;
  let brushSize = 8;
  let colorMode = 'rainbow';
  let brushType = 'round';
  let hue = 0;
  let drawing = false;
  let lastX = 0, lastY = 0;
  let history = []; // for undo
  const MAX_HISTORY = 20;

  // ── Color palettes ──
  const palettes = {
    rainbow: (h) => `hsl(${h % 360}, 90%, 60%)`,
    ocean: (h) => {
      const t = (h % 360) / 360;
      const r = Math.round(6 + 50 * t);
      const g = Math.round(78 + 130 * t);
      const b = Math.round(123 + 130 * (1 - t));
      return `rgb(${r},${g},${b})`;
    },
    sunset: (h) => {
      const t = (h % 360) / 360;
      const r = Math.round(200 + 55 * Math.sin(t * Math.PI));
      const g = Math.round(60 + 130 * t);
      const b = Math.round(18 + 200 * t * t);
      return `rgb(${r},${g},${b})`;
    },
    aurora: (h) => {
      const t = (h % 360) / 360;
      const r = Math.round(67 + 96 * Math.sin(t * Math.PI * 2));
      const g = Math.round(56 + 155 * t);
      const b = Math.round(202 - 140 * t);
      return `rgb(${Math.max(0,Math.min(255,r))},${Math.max(0,Math.min(255,g))},${Math.max(0,Math.min(255,b))})`;
    },
    white: () => `rgba(230, 230, 230, 0.9)`,
  };

  // ── Undo ──
  function saveState() {
    if (history.length >= MAX_HISTORY) history.shift();
    history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
  }

  function undo() {
    if (history.length === 0) return;
    const state = history.pop();
    ctx.putImageData(state, 0, 0);
  }

  // ── Draw kaleidoscope segment ──
  function drawSegment(x1, y1, x2, y2, color, size) {
    const angle = (Math.PI * 2) / symmetry;

    for (let i = 0; i < symmetry; i++) {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angle * i);

      // Normal
      drawStroke(x1 - cx, y1 - cy, x2 - cx, y2 - cy, color, size);

      // Mirror
      ctx.scale(1, -1);
      drawStroke(x1 - cx, y1 - cy, x2 - cx, y2 - cy, color, size);

      ctx.restore();
    }
  }

  function drawStroke(rx1, ry1, rx2, ry2, color, size) {
    if (brushType === 'round') {
      ctx.beginPath();
      ctx.moveTo(rx1, ry1);
      ctx.lineTo(rx2, ry2);
      ctx.strokeStyle = color;
      ctx.lineWidth = size;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();
    } else if (brushType === 'glow') {
      ctx.beginPath();
      ctx.moveTo(rx1, ry1);
      ctx.lineTo(rx2, ry2);
      ctx.strokeStyle = color;
      ctx.lineWidth = size * 0.5;
      ctx.lineCap = 'round';
      ctx.shadowColor = color;
      ctx.shadowBlur = size * 2;
      ctx.stroke();
      ctx.shadowBlur = 0;
    } else if (brushType === 'ribbon') {
      const dx = rx2 - rx1;
      const dy = ry2 - ry1;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const nx = -dy / (dist || 1) * size * 0.5;
      const ny = dx / (dist || 1) * size * 0.5;

      ctx.beginPath();
      ctx.moveTo(rx1 + nx, ry1 + ny);
      ctx.quadraticCurveTo(
        (rx1 + rx2) / 2 + nx * 2,
        (ry1 + ry2) / 2 + ny * 2,
        rx2 + nx, ry2 + ny
      );
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.5;
      ctx.lineCap = 'round';
      ctx.globalAlpha = 0.7;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
  }

  // ── Trail / fade ──
  function applyTrail() {
    const fadeAlpha = 1 - trailPersistence;
    if (fadeAlpha > 0.001) {
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = `rgba(0,0,0,${fadeAlpha * 0.06})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
  }

  // ── Idle sparkle particles ──
  const particles = [];
  const MAX_PARTICLES = 60;

  function spawnIdleParticle() {
    if (drawing || particles.length >= MAX_PARTICLES) return;
    const angle = Math.random() * Math.PI * 2;
    const radius = 40 + Math.random() * Math.min(cx, cy) * 0.7;
    particles.push({
      x: cx + Math.cos(angle) * radius,
      y: cy + Math.sin(angle) * radius,
      vx: (Math.random() - 0.5) * 0.3,
      vy: (Math.random() - 0.5) * 0.3,
      life: 1,
      decay: 0.003 + Math.random() * 0.006,
      size: 1 + Math.random() * 2,
      hue: Math.random() * 360,
    });
  }

  function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.life -= p.decay;
      if (p.life <= 0) { particles.splice(i, 1); continue; }

      const color = palettes[colorMode](p.hue + hue);
      ctx.save();
      ctx.globalAlpha = p.life * 0.5;
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  // ── Center mandala decoration ──
  function drawCenterDecor() {
    const time = performance.now() * 0.001;
    const pulseR = 20 + Math.sin(time * 0.8) * 4;
    const angle = (Math.PI * 2) / symmetry;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.globalAlpha = 0.12 + Math.sin(time) * 0.04;

    // Subtle rotating guides
    for (let i = 0; i < symmetry; i++) {
      ctx.beginPath();
      ctx.moveTo(0, 0);
      const r = Math.min(cx, cy) * 0.85;
      ctx.lineTo(Math.cos(angle * i + time * 0.1) * r, Math.sin(angle * i + time * 0.1) * r);
      ctx.strokeStyle = `hsla(${(hue + i * 30) % 360}, 60%, 60%, 0.15)`;
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    // Center circle
    ctx.beginPath();
    ctx.arc(0, 0, pulseR, 0, Math.PI * 2);
    ctx.strokeStyle = `hsla(${hue % 360}, 70%, 70%, 0.3)`;
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(0, 0, 3, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${hue % 360}, 70%, 80%, 0.5)`;
    ctx.fill();

    ctx.restore();
  }

  // ── Animation loop ──
  let animFrame;
  let lastTime = 0;
  let idleTimer = 0;

  function animate(time) {
    animFrame = requestAnimationFrame(animate);
    const dt = time - lastTime;
    lastTime = time;

    hue += dt * 0.05;

    applyTrail();
    drawCenterDecor();

    // Idle sparkle
    if (!drawing) {
      idleTimer += dt;
      if (idleTimer > 80) {
        idleTimer = 0;
        spawnIdleParticle();
      }
    }
    updateParticles();
  }

  animFrame = requestAnimationFrame(animate);

  // ── Input handling ──
  function getPos(e) {
    if (e.touches && e.touches.length > 0) {
      return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
    return { x: e.clientX, y: e.clientY };
  }

  function isUIElement(e) {
    const el = e.target;
    return el.closest('.top-bar') || el.closest('.bottom-panel') || el.closest('.intro');
  }

  function onStart(e) {
    if (isUIElement(e)) return;
    e.preventDefault();
    saveState();
    drawing = true;
    const pos = getPos(e);
    lastX = pos.x;
    lastY = pos.y;
  }

  function onMove(e) {
    const pos = getPos(e);

    // Update brush indicator
    brushIndicator.style.width = brushSize + 'px';
    brushIndicator.style.height = brushSize + 'px';
    brushIndicator.style.left = (pos.x - brushSize / 2) + 'px';
    brushIndicator.style.top = (pos.y - brushSize / 2) + 'px';
    brushIndicator.style.opacity = '1';

    if (!drawing) return;
    e.preventDefault();

    const color = palettes[colorMode](hue);
    drawSegment(lastX, lastY, pos.x, pos.y, color, brushSize);

    lastX = pos.x;
    lastY = pos.y;
    hue += 1.5;
  }

  function onEnd(e) {
    drawing = false;
  }

  canvas.addEventListener('mousedown', onStart);
  canvas.addEventListener('mousemove', onMove);
  canvas.addEventListener('mouseup', onEnd);
  canvas.addEventListener('mouseleave', (e) => {
    drawing = false;
    brushIndicator.style.opacity = '0';
  });

  canvas.addEventListener('touchstart', onStart, { passive: false });
  canvas.addEventListener('touchmove', onMove, { passive: false });
  canvas.addEventListener('touchend', onEnd);
  canvas.addEventListener('touchcancel', onEnd);

  // ── UI ── Symmetry
  const symGroup = document.getElementById('symmetryGroup');
  symGroup.addEventListener('click', (e) => {
    const btn = e.target.closest('[data-sym]');
    if (!btn) return;
    symmetry = parseInt(btn.dataset.sym);
    symGroup.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });

  // ── UI ── Brush type
  const brushGroup = document.getElementById('brushGroup');
  brushGroup.addEventListener('click', (e) => {
    const btn = e.target.closest('[data-brush]');
    if (!btn) return;
    brushType = btn.dataset.brush;
    brushGroup.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });

  // ── UI ── Sliders
  const trailSlider = document.getElementById('trailSlider');
  trailSlider.addEventListener('input', () => {
    trailPersistence = trailSlider.value / 100;
  });

  const sizeSlider = document.getElementById('sizeSlider');
  sizeSlider.addEventListener('input', () => {
    brushSize = parseInt(sizeSlider.value);
  });

  // ── UI ── Color modes
  const colorModes = document.getElementById('colorModes');
  colorModes.addEventListener('click', (e) => {
    const dot = e.target.closest('[data-color]');
    if (!dot) return;
    colorMode = dot.dataset.color;
    colorModes.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
    dot.classList.add('active');
  });

  // ── UI ── Clear
  document.getElementById('btnClear').addEventListener('click', () => {
    saveState();
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
    showToast('Canvas cleared');
  });

  // ── UI ── Undo
  document.getElementById('btnUndo').addEventListener('click', () => {
    undo();
    showToast('Undo');
  });

  // ── UI ── Save
  document.getElementById('btnSave').addEventListener('click', () => {
    // Create a clean copy without UI
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.fillStyle = '#000';
    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
    tempCtx.drawImage(canvas, 0, 0);

    const link = document.createElement('a');
    link.download = `kaleidoscope-${Date.now()}.png`;
    link.href = tempCanvas.toDataURL('image/png');
    link.click();
    showToast('Screenshot saved');
  });

  // ── UI ── Intro
  const intro = document.getElementById('intro');
  document.getElementById('btnStart').addEventListener('click', () => {
    intro.classList.add('hidden');
  });

  // ── Toast ──
  let toastTimer;
  function showToast(msg) {
    const toast = document.getElementById('toast');
    toast.textContent = msg;
    toast.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.classList.remove('show'), 1500);
  }

  // ── Keyboard shortcuts ──
  document.addEventListener('keydown', (e) => {
    if (e.key === 'z' && (e.metaKey || e.ctrlKey)) {
      e.preventDefault();
      undo();
    }
    if (e.key === 'c' && !e.metaKey && !e.ctrlKey) {
      document.getElementById('btnClear').click();
    }
    if (e.key === 's' && (e.metaKey || e.ctrlKey)) {
      e.preventDefault();
      document.getElementById('btnSave').click();
    }
  });

  // Dismiss intro on any canvas touch/click
  canvas.addEventListener('mousedown', () => intro.classList.add('hidden'), { once: true });
  canvas.addEventListener('touchstart', () => intro.classList.add('hidden'), { once: true });

})();
</script>
</body>
</html>
